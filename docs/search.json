[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Apuntes Prácticas de la asignatura de Bioestadística",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "PR_0_lect.html",
    "href": "PR_0_lect.html",
    "title": "1  PR0-Buenas prácticas en recopilación de datos",
    "section": "",
    "text": "2 Criterios de buena praxis en la recopilación de datos.\nComo veremos al termina la sección, no siempre contamos con la mejor solución a la hora de recoger los datos, pero esto no evita la necesidad de recogerlos con la mayor calidad posible, tarea que comienza incluso antes de su recogida. Siendo esencial, en esta sesión no hablaremos de la importancia de la definición adecuada de las variables, algunos de cuyos aspectos habrán sido ya comentados en las clases presenciales. En este texto solo daremos algunas pautas para mejorar su introducción en el primero soporte disponible antes a su importación al software de análisis."
  },
  {
    "objectID": "PR_0_lect.html#buenas-prácticas-sobre-gestión-de-datos.",
    "href": "PR_0_lect.html#buenas-prácticas-sobre-gestión-de-datos.",
    "title": "1  PR0-Buenas prácticas en recopilación de datos",
    "section": "2.1 Buenas prácticas sobre gestión de datos.",
    "text": "2.1 Buenas prácticas sobre gestión de datos.\nPoco textos sobre estadística incluyen un apartado sobre buenas prácticas en la introducción de datos, posiblemente porque asumen que el análisis empieza cuando los datos están listos.\nSin embargo, cualquier persona dedicada al análisis de datos le dirá que el 75% de su trabajo consiste en “limpiar los datos” Ruiz (2017). Aquí no estamos hablando del diseño del estudio, de la ausencia de sesgos, de la calidad (errores de medida) con la que se recogen las variables, o de si el tamaño muestral es o no el adecuado para nuestro fin. Hablamos de la cantidad de trabajo que hay que dedicar porque la base de datos que recibimos no sigue algunos principios básicos para poder analizarla con la mínima intervención.\nNunca será suficiente el tiempo invertido a esta cuestión, por eso incluyo aquí algunos principios recogidos en este artículo Wickham (2014) y por supuesto en el libro Grolemund and Wickham (2017) de Grolemund y Hadley Wickham, cofundador y científico jefe de RStudio™ (ahora Posit™).\n\n2.1.1 Recomendaciones.\nPuede ampliar la información en el artículo de Broman and Woo (2018) y en la web de datacarpentry The Carpentries (n.d.), donde encontrará multitud de consejos sobre cómo no utilizar las hojas de cálculo para recoger datos.\n\n2.1.1.1 Spreadsheets\n\nBe consistent\nChoose good names for things\nWrite dates as YYYY-MM-DD\nNo empty cells\nPut just one thing in a cell\nDon’t use font color or highlighting as data\nSave the data as plain text files\n\nCarrie Wright, Shannon Ellis, Stephanie Hicks and Roger D. Peng. Tidyverse Skills for Data Science in R (Posición en Kindle124-126). leanpub.com.\n\n2.1.1.1.1 Be consistent, concretamente…\n\n“Use consistent codes for categorical variables”-> avoid m, male, Male, mal…\n“Use a consistent fixed code for any missing values.” -> NA. Avoide numbers (999), do not insert notes.\n“Use consistent variable names”: Chol_1mth, then Chol_6mth…\n“Use consistent subject identifiers.”: (histclin, specimenid,…) KeyField!\n“Use a consistent data layout in multiple files.” : Evita trabajo extra al analista al combinarlos.\n“Use consistent file names.” Ejemplo “hiv_tfgm_2022_03_01.csv”, * “hiv_tfgm_2022_04_03.csv”\n“Use a consistent format for all dates” ‘YYYY-MM-DD’ ISO8601 (si otro, siempre igual. Cuidado con Excel)\n“Use consistent phrases in your notes” (Si las tienes, puede que quieras analizarla.\n“Be careful about extra spaces within cells.”\n\n\n\n2.1.1.1.2 Good variable names.\n\n\n\n2.1.1.1.3 Date formats+not empty cells.\n\n\n\n2.1.1.1.4 Just one thing in a cell + don´t use highlighting as data.\n\n\n\n2.1.1.1.5 Save as .csv.\nAunque es posiblemente uno de los tipos de archivo más usados para recopilar datos, en realidad Excel está lejos de ser un programa diseñado para este fin, y recientemente el uso de su antiguo formato (.xls) produjo un importante error en Reino Unido al ser utilizado en la recopilación de datos durante la pandemia por SARS-Cov2 Kelion (2020). Aunque la culpa no era de MSExcel, cuyo formato desde 2007 (.xlsx) no tiene la limitación del antiguo, lo cierto es que se suele recomendar evitar su uso para recopilar datos.\nLas bases de datos profesionales utilizan otros lenguajes y formatos. En R existen paquetes que permiten importar datos de la mayoría de estas fuentes, incluso de otros programas de análisis (SPSS, Stata, SAS…) pero, aunque no existiesen, cualquiera de ellos es capaz de exportarlos a un pequeño archivo .csv (comma separated values), que es a su vez importable desde todos ellos, también por R. Esto convierte al formato .csv en un formato frecuente en el intercambio de datos cuando no existe otro camino.\n\nAunque podríamos “crear” y editar los datos en el propio R1, esto no es recomendable, entre otras cosas por la pérdida de reproducibilidad que conlleva, y por la ausencia de controles de entrada que sí están disponibles en las bases de datos que utilizan formularios que permiten asegurar cierta calidad durante su introducción, por ejemplo mediante listas desplegables que impiden introducir valores no incluidos en ellas o mediante filtros de valor que evitan introducir valores imposibles (p.ej. edad =999).\nDicho esto, es obvio que muchos usuarios que sabrían rellenar una hoja de Excel (en el fondo una estructura tabular), no cuentan con conocimientos suficientes para crear una base de datos utilizando una estructura de tablas relacionadas, asociadas a formularios con controles de entrada sobre consultas SQL, y tampoco cuentan con apoyo técnico para poder hacerlo, por lo que muchos no tendrán más remedio que recurrir a archivos .xlsx. De hacerlo, es aún más importante seguir las recomendaciones anteriores de cara a facilitar su importación y reducir los errores de introducción.\nPor todo lo expuesto, lo más frecuente es que los datos crudos hayan sido recogidos en alguno de estos formatos (también en Excel), por nosotros mismos o por terceros, y por lo tanto debemos ser capaces de importarlos. Esto lo veremos en siguientes sesiones.\nPor último, algunos de los paquetes de R (ya veremos qué es esto) incluyen datos que permiten seguir los ejemplos. En la siguiente sesión también veremos cómo cargarlos (en este caso no es una importación) de forma sencilla."
  },
  {
    "objectID": "PR_0_lect.html#referencias.",
    "href": "PR_0_lect.html#referencias.",
    "title": "1  PR0-Buenas prácticas en recopilación de datos",
    "section": "2.2 Referencias.",
    "text": "2.2 Referencias.\n\n\n\n\nBroman, Karl W., and Kara H. Woo. 2018. “Data Organization in Spreadsheets.” The American Statistician 72 (1): 2–10. https://doi.org/10.1080/00031305.2017.1375989.\n\n\nGandrud, Christopher. 2020. Reproducible Research with R and RStudio. Boca Raton, FL.\n\n\nGrolemund, Garrett, and Hadley Wickham. 2017. R for Data Science. 1st edition. Sebastopol, CA: O’Reilly Media. http://r4ds.had.co.nz/.\n\n\nKelion, Leo. 2020. “Excel: Why Using Microsoft’s Tool Caused Covid-19 Results to Be Lost.” BBC News, October. https://www.bbc.com/news/technology-54423988.\n\n\nRuiz, Armand. 2017. “The 80/20 Data Science Dilemma.” InfoWorld. https://www.infoworld.com/article/3228245/the-80-20-data-science-dilemma.html.\n\n\nThe Carpentries. n.d. “Formatting Problems Data Organization in Spreadsheets for Ecologists.” Accessed December 1, 2022. https://datacarpentry.org/spreadsheet-ecology-lesson/02-common-mistakes.html.\n\n\nWickham, Hadley. 2014. “Tidy Data.” Journal of Statistical Software 59 (September): 1–23. https://doi.org/10.18637/jss.v059.i10."
  },
  {
    "objectID": "PR_1_lect.html",
    "href": "PR_1_lect.html",
    "title": "2  PR1-Introducción a R y RStudio.",
    "section": "",
    "text": "3 Introducción a R+RStudio.\nEste documento no aborda aspectos como la instalación de R y RStudio, aspectos bien cubiertos en muchos otros recursos, algunos mencionados en la bibliografía.\nEl siguiente esquema trata de representar el flujo de trabajo habitual en cualquier proyecto de data science independientemente de su envergadura.\nEn la preparación de cualquier trabajo de investigación en el que nosotros nos encarguemos del análisis pasaremos por todas, o casi todas, estas fases.\nEn sentido estricto, el análisis estadístico sería el ciclo Transform-Visualise-Model, pero es imposible llegar a estas fases si no se completan los pasos anteriores.\nPor otro lado, sería extraño realizar un análisis para no comunicarlo, por lo que, aunque las siguientes notas no siguen exactamente este esquema, es importante tratar de pensar a qué fase corresponde todo lo que veremos en la parte práctica."
  },
  {
    "objectID": "PR_1_lect.html#por-qué-utilizar-r-para-analizar-los-datos-de-tu-investigación",
    "href": "PR_1_lect.html#por-qué-utilizar-r-para-analizar-los-datos-de-tu-investigación",
    "title": "2  PR1-Introducción a R y RStudio.",
    "section": "3.1 ¿Por qué utilizar R para analizar los datos de tu investigación?",
    "text": "3.1 ¿Por qué utilizar R para analizar los datos de tu investigación?\n\n3.1.1 Ventajas:\n\nCódigo vs. ventanas. (En realidad, SPSS, Stata, SAS… también se pueden utilizar usando código)\nReproducibilidad (interna y externa).\nReplicabilidad.\nVelocidad.\nAyuda de la comunidad (software libre).\nMultitud de recursos.\nNadie te acusará de estar pirateando software.\nUna vez conoces los fundamentos, puedes crecer lo que desees.\n\n\n\n3.1.2 Desventaja.\n\nCurva de aprendizaje lenta en comparación con las ventanas."
  },
  {
    "objectID": "PR_1_lect.html#instalación-de-r-y-rstudio.",
    "href": "PR_1_lect.html#instalación-de-r-y-rstudio.",
    "title": "2  PR1-Introducción a R y RStudio.",
    "section": "3.2 Instalación de R y RStudio.",
    "text": "3.2 Instalación de R y RStudio.\nEs conveniente instalar R y luego RStudio.\n\nInstalar R desde aquí: https://cran.r-project.org/\nInstalar RStudio Desktop desde aquí: https://posit.co/downloads/\n\nPara detalles sobre la instalación y otros aspectos básicos, este recurso creado por Anabel Forte Deltell (más conocida como BayesAna)  es un buen punto de arranque."
  },
  {
    "objectID": "PR_1_lect.html#trabajando-con-rrstudio.",
    "href": "PR_1_lect.html#trabajando-con-rrstudio.",
    "title": "2  PR1-Introducción a R y RStudio.",
    "section": "3.3 Trabajando con R+RStudio.",
    "text": "3.3 Trabajando con R+RStudio.\n\n3.3.1 Conceptos básicos para comenzar a trabajar .\nAunque no en este orden, repasaremos todos estos conceptos durante la sesión.\nNo hace falta que los memorices ahora. Se trata de conceptos que irás incorporando mientras practicas con RStudio.\n\nWorkspace, directorio de trabajo , Imagen (.RData).\nPaneles: Console, Script,Environment/History/Connection/Tutorial .\nMétodos abreviados de teclado útiles. Ctrl+Intro, Ctrl+Shift+C, Ctrl+Shift+N…\nCómo instalar bibliotecas (library).\nCómo abrir o llamar a una biblioteca: require(), library().\nCómo llamar a las funciones de una biblioteca (la posición de los argumentos es relevante).\nOrganización del script: Comentar, Outline, ejecución de líneas.\nCómo pedir ayuda en Rstudio y en internet.\n\n\n\n\nPaneles en RStudio\n\n\n\n\n3.3.2 Primeros pasos.\n\n\n3.3.3 Recordando cómo “piensa” R.\n\n\n\nCómo piensa R\n\n\n\n\n\n\n\n3.3.4 Uso de la ayuda de R: help, ? o ??.\n\nhelp.start() #Abre el navegador (solo si tenemos la ayuda html instalada)\nhelp.search(“normal”) # Busca términos relacionados.\n\nCómo consultar la ayuda de R:\n\n? Consulta de ayuda para funciones.\n\nhelp(stats) es lo mismo que ?stats.\n\n?? busca el texto texto en las páginas de ayuda ??stats.\nSi se trata de caracteres o de expresiones reservadas porque se utilizan en operaciones básicas (como +) o en el interior de otras funciones s (como if ), es necesario rodear la expresión con “” para que devuelva la ayuda.\nCorrecto help(“if”) o ?“if” vs. Incorrecto: help(if) p ?if\n\n\n\n3.3.5 Instalar paquetes y llamarlos no son la misma cosa.\nCuando explico este tema, suelo utilizar el ejemplo que sugieren los nombres que vamos a utilizar, solo que en otro contexto.\nInstalar la librería (install.packages(‘library_name’)) significa ir a la tienda y comprar la biblioteca (library) con los libros incluidos.\nCargarla (library(library_name)) o llamarla (require(library_name)) sería equivalente a abrir la librería y ponerla a disposición del usuario.\nLlamar a una de las funciones que contiene sería equivalente a utilizar uno de los libros (function_name(args,…)), libro que puedo usar de muchas formas, siempre que conozca los los argumentos para poder hacerlo de la forma que yo deseo.\n\nNota:\n\n\nAunque no son exactamente lo mismo, escuchará library, biblioteca o paquete para referirse a estas bibliotecas (traducción al español de library).\nPara utilizar las funciones anteriores, deberá sustituir library_name por el nombre de la biblioteca (library) que corresponda, y function_name por la función de dicha librería que desee utilizar.\n\nInstalar un paquete implica copiar una serie de archivos en su ordenador en una carpeta ubicada en un subdirectorio bajo la carpeta de R, es decir es un hecho físico constatable.\n\nNota: Se puede cambiar la ubicación pero de momento recomendamos que deje a R instalarlos en la ubicación por defecto que contiene todas las bibliotecas [libraries]. Para ver qué librerías tenemos instaladas, podemos utilizar la función installed.packages(). Verá que pueden estar en diferentes ubicaciones.\n\nCargar la librería es ponerla en una zona de memoria que la hace disponible, de forma que basta con llamar a las funciones. En realidad se puede llamar a las funciones sin cargar la librería, pero deberemos llamarla cada vez que ejecutemos una de las funciones que contenga. Para esto se usa la expresión library_name::function().\n\n\n3.3.6 Tipos de objetos en R (los básicos).\n\nEscalar.\nArray: Agrupación multidimiensional de vectores. Todos elementos del mismo tipo.\nVectores: Numéricos, Lógicos, Cadenas, Factores. Como es Array->todos elementos del mismo tipo\nMatrices (matrix). Array de dim=2. Como es Array->todos elementos del mismo tipo.\ndataframes (data.frame). Matrices que pueden contener elementos de varios tipos, pero todos de la misma longitud.\nListas (list). Elementos puedes ser de diferentes tipos y longitudes.\nFunciones (function): conjunto de código de R ejecutable y parametrizable.\nNota: Todos los objetos tienen atributos length y mode. Los arrays además tienen dim.\n\n\n\n3.3.7 Organización del script.\n\nLas funciones se pueden separar por “;” o por un salto de línea.\nSe puede escribir en más de una línea y se pueden agrupar “{}” dentro de una función.\nEl carácter para comentar código en R es # {\\(Hash\\)}. Evita que se ejecute una o varias líneas de código, y por tanto también permite introducir líneas de texto que nos ayuden recordar por qué creamos el código de esa manera. Es lo que llamaremos “comentar el código”\nEs importante recordar que el código es:\nCase-sensitive: Sensible a mayúsculas y minúsculas: Norm es diferente de norm. - Completo (multilinea): El código ha de estar completo para ser ejecutado\nCoherente. () []: Los paréntesis han de ser coherentes (cada apertura su cierre).\nCuidado con caracteres reservados: =, $, &, *, o prohibidos ä,ü,í,…: Reservados para cometidos concretos, mejor evitar ñ y otros caracteres “extraños”."
  },
  {
    "objectID": "PR_1_lect.html#primer-script.",
    "href": "PR_1_lect.html#primer-script.",
    "title": "2  PR1-Introducción a R y RStudio.",
    "section": "3.4 Primer script.",
    "text": "3.4 Primer script.\nAbre una pestaña para crear tu primer script. Lo puedes hacer desde el menú File/New File/R script o con el método de teclado abreviado Ctrl+May+N1.\nSe abrirá una pestaña que señala el nuevo script. Pega en ese espacio el siguiente código:\n\nlibrary(car) # carga la biblioteca, que a su vez permite el acceso a los datos de una base de datos sobre coches.\n\nCargando paquete requerido: carData\n\n\n\nAdjuntando el paquete: 'car'\n\n\nThe following object is masked from 'package:dplyr':\n\n    recode\n\n\nThe following object is masked from 'package:purrr':\n\n    some\n\nsummary(cars) # resume los datos.\n\n     speed           dist       \n Min.   : 4.0   Min.   :  2.00  \n 1st Qu.:12.0   1st Qu.: 26.00  \n Median :15.0   Median : 36.00  \n Mean   :15.4   Mean   : 42.98  \n 3rd Qu.:19.0   3rd Qu.: 56.00  \n Max.   :25.0   Max.   :120.00  \n\nplot(cars) # construye un gráfico con los datos.\n\n\n\n\nComo ves, aunque las funciones están en inglés, el código de R es bastante comprensible para un humano.\nPuede salvar el script pulsando el disquete azul bajo la pestaña…\n\n\n\nSave script\n\n\n… o más fácil, con la combinación de teclas Ctrl+s.\nLas personas que utilizamos R para enseñar estadística tenemos diferentes opiniones sobre si debemos enseñar a utilizar lo que llamamos base R (las funciones más básicas de R, en su mayoría incluidas en un paquete llamado base) o si es mejor ir directamente hacia lo que llamamos modern R, que utiliza algo llamado pipes (%>% o más recientemente |>) que simplifica enormemente el código necesario para realizar tareas complejas.\nDe hecho, aunque prácticamente todo se podría construir con rbase, el uso del denominado tidyverse (que incluye un conjunto de paquetes bajo esta filosofía) agiliza mucho el trabajo, por lo que es con lo que finalmente todos trabajamos.\n¿Merece la pena aprender algo de rbase?\nEn mi opinión sí, porque aunque utilices pipes, de vez en cuando afloran conceptos básicos. Otros profesores, en cambio, opinan que es mejor llevar al alumnado directamente al tidyverse porque al final es lo que vais a utilizar.\nNosotros pensamos que saber indexar, conocer los tipos de objetos, las clases de vectores, etc te ayudara a entender y solucionar los problemas que seguro aparecerán en el tidyverse, a descifrar los mensajes de error y sobre todo a comprender las soluciones que encontrarás en los blogs dedicados a este tema.\nLas próximas líneas están dedicadas a mostrar algunas funciones básicos que ayudan a comprender los diferentes objetos y estructuras con las que vamos a trabajar, aunque luego muchas de estas funciones permanecerán escondidas en el interior de funciones más complejas contenidas en otros paquetes."
  },
  {
    "objectID": "PR_1_lect.html#creación-de-objetos.",
    "href": "PR_1_lect.html#creación-de-objetos.",
    "title": "2  PR1-Introducción a R y RStudio.",
    "section": "3.5 Creación de objetos.",
    "text": "3.5 Creación de objetos.\nAnteriormente hemos mencionado algunos de los objetos habitualmente utilizados en R. Ahora vamos a aprender a crearlos.\nEsto es una expresión…que devuelve un resultado. No ha creado un objeto.\n\n5+3\n\n[1] 8\n\n\nY esto es una asignación, que crea un objeto (en el ejemplo un escalar con nombre x), en el que almacenamos el/los resultado/s (o la función) de, en este caso, una suma. El objeto se almacena en memoria y se lo puede llamar en cualquier momento.\n\nx<-5+3\nx\n\n[1] 8\n\n\nLas funciones utilizan estos objetos para generar nuevos objetos, pero hay algunas funciones básicas que nos ayudan a gestionar estos objetos en nuestro espacio de trabajo2.\nMencionaré tres de ellas3:\n\nc(): Concatena elementos y crea un vector, uno de los objetos más sencillos en R.\nls(): Lista los objetos en el espacio de trabajo.\nrm(): Elimina objetos del espacio.\n\nEjemplo de uso:\n\n3.5.0.1 Array (vector, matrix, array)\nUn array contiene un conjunto de elementos (números o caracteres) del mismo tipo en una estructura ordenada. En función de las dimensiones puede ser un vector (1 dimensión), una matriz (2 dimensiones) o un array (3 dimensiones).\nImportante: Solo puede contener elementos del mismo tipo\n\n\n3.5.0.2 Vectores.\n\ny<-c(4,8,22,32,25) #crea un vector de 5 elementos que son números (escalares)\ny # llamamos al objeto para que lo devuelva.\n\n[1]  4  8 22 32 25\n\nnombres<-c('Juan','Luis','Mónica','Julia') #Genera un vector que contiene cadenas de caracteres.\nnombres #llamamos al objeto para que lo devuelva.\n\n[1] \"Juan\"   \"Luis\"   \"Mónica\" \"Julia\" \n\n\nComo se puede observar en el código anterior, hay una parte del texto detrás del carácter **#**. Todos los lenguajes de programación utilizan caracteres para \"comentar\" texto. El *texto comentado* no se considera parte del código, por lo que sirve para, por ejemplo, dejar explicaciones de por qué cierta parte del código se escribió de una determinada manera, o para que cierto fragmento del código no se ejecute.\nObtener la lista de objetos en nuestro espacio de trabajo es así de sencillo.\n\nls()\n\n[1] \"nombres\" \"x\"       \"y\"      \n\n\nY eliminarlos también.\n\nrm(nombres)\n\nComprobamos que lo ha eliminado.\n\nls()\n\n[1] \"x\" \"y\"\n\n\nAlgunas funciones nos ayudan a crear vectores de manera más rápida. Aquí van algunos ejemplos que nos pueden ser útiles más adelante, por ejemplo cuando hablemos de indexación:\n\na1<-rep(1,20) #Repitiendo elementos.\nb<-seq(1,20,2)  # Construyendo sucesiones, por ejemplo aritmética de distancia 2 comenzando el el 1.\nd<-27:42 #cuando la distancia es uno se puede abreviar así.\nvecnam.rep<-rep(c('Julia','Óscar'),4)\n\nIncluso podemos combinar (anidar) funciones.\n\na2<-rep(1:3,10) #Repitiendo elementos\na2\n\n [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3\n\n# En realidad estamos anidando la función seq dentro de la función rep. \na2.1 <- rep(seq(1,3),10)\na2.1\n\n [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3\n\na3<-rep(1:2,each=10) #Repitiendo elementos, pero de otra manera.\na3\n\n [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2\n\n\nComo hemos visto anteriormente, existen objetos de muchos tipos: Array, matriz, vector (en realidad estos dos últimos son tipos de array), lista, dataframe…. Cuando se crean, almacenan y eliminan igual que los vectores del ejemplo anterior, indepedientente de lo complejos o grandes que sean.\n\n\n3.5.0.3 Matrices.\nEn el siguiente ejemplo, vamos a crear una matriz. Esto nos servirá para explicar un concepto importante, la indexación de elementos.\nCreación de una matriz.\nGeneramos una matriz don dos columnas (a partir de los elementos calcula las filas necesarias), llamada m1. Por defecto los elementos se van introduciendo en la matriz columna a columna.\n\nm1<-matrix(c(2,5,8,9,20,5,8,9),ncol=2) \nm1\n\n     [,1] [,2]\n[1,]    2   20\n[2,]    5    5\n[3,]    8    8\n[4,]    9    9\n\n\nPero podemos cambiar la forma en la que los introduce, basta con utilizar un nuevo argumento byrow para que la rellene línea a línea.\n\nm2<-matrix(c(2,5,8,9,20,5,8,9),ncol=2,byrow = T) \nm2\n\n     [,1] [,2]\n[1,]    2    5\n[2,]    8    9\n[3,]   20    5\n[4,]    8    9\n\n\nComo se puede observar, en los bordes aparecen las coordenadas. Al ser un objeto bidimensional el primer espacio hace referencia a la fila y el segundo a la columna:[fila,columna]\nEn el caso del vector, que solo tiene una dimensión, no habría el elemento columna.\nPues bien, indexar un objeto significa poder llamar a subconjuntos dentro del mismo utilizando las coordenadas.\nIndexando un vector.\n\na2[c(1,2,6)] #extrae elementos que ocupan las posiciones 1,2 y 6 en el vector.\n\n[1] 1 2 3\n\nvecnam.rep[seq(1,8,2)] #extrae elemantos que ocupan las posiciones del 1 a 8, pero saltando de 2 en 2 (1,3,5,7)\n\n[1] \"Julia\" \"Julia\" \"Julia\" \"Julia\"\n\n\nIndexando una matriz.\nLa indexación también nos permite extraer una parte de una matriz. Puede ser un conjunto de columnas, un conjunto de filas, o las celdas ([fila,columna)] que le indiquemos.\nEn el siguiente código se muestran varios ejemplos.\n\nm1 #Esta es la matriz que creamos anteriormente.\n\n     [,1] [,2]\n[1,]    2   20\n[2,]    5    5\n[3,]    8    8\n[4,]    9    9\n\nm1[c(1,2),] # Extraigo filas 1 y 2\n\n     [,1] [,2]\n[1,]    2   20\n[2,]    5    5\n\nm1[,c(1,2)] # Extraigo columnas 1 y 2\n\n     [,1] [,2]\n[1,]    2   20\n[2,]    5    5\n[3,]    8    8\n[4,]    9    9\n\nm1[c(3,4),c(1,2)] # Extraigo un subconjunto de celdas.\n\n     [,1] [,2]\n[1,]    8    8\n[2,]    9    9\n\n\n\n\n3.5.0.4 Array.\nSe pueden crear objetos con más de dimensiones, pero no vais a encontrar muchos ejemplos en el uso habitual.\n\nar<-array(c(1,4,4,8,9,9,9.8,9,8,9,9.2,4,5,9,10,3,4,8),c(2,3,2)) #Esto es un array de 2 filas (primera dimension), 3 columnas (segunda dimensión), 2 bloques (tercera dimension)\nar\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    4    9\n[2,]    4    8    9\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]  9.8    8  9.2\n[2,]  9.0    9  4.0\n\n\nComo no son de uso habitual, no profundizaré en su uso. Como podéis ver, elementos han de ser del mismo tipo, en este caso numéricos, pero podrían ser caracteres (texto).\n\nar2 <- array(rep(c('red','yellow','green'),6),c(2,3,2))\nar2\n\n, , 1\n\n     [,1]     [,2]    [,3]    \n[1,] \"red\"    \"green\" \"yellow\"\n[2,] \"yellow\" \"red\"   \"green\" \n\n, , 2\n\n     [,1]     [,2]    [,3]    \n[1,] \"red\"    \"green\" \"yellow\"\n[2,] \"yellow\" \"red\"   \"green\" \n\n\nComo veis ha producido un array con las mismas dimensiones pero ahora contiene texto.\nPor cierto, puede que os llame la atención que al utilizar nombres de colores en inglés el texto aparece del color correspondiente. Esta mejora se incluyó en una de las recientes versiones de RStudio y es porque este vector con colores se puede utilizar al definir colores en un gráfico4\nSoy consciente de que hasta aquí puede no haber visto la utilidad de lo expuesto, pero créeme que si entiende estos conceptos, te serán de utilidad cuando trabajes con datos.\nAsí llegamos un objeto clave para el análisis de datos con R: el dataframe.\n\n\n3.5.0.5 Dataframe\nComo ya comentamos se trata de una estructura con forma de matriz (todos los vectores han de tener la misma longitud), pero a diferencia de esta, un dataframe sí puede contener información de distinto tipo, fundamentalmente números (integer o numeric), de caracteres (texto), lógicos (TRUE/FALSE) y factores (este último será la forma en la que recomendaremos guardar variables categóricas y por su especificidad le dedicaremos un epígrafe propio).\nEl dataframe es la estructura en la que vamos a almacenar nuestros datos, por lo que, aunque se pueden construir desde la combinación de matrices o vectores, lo frecuente es que los construyamos importando datos desde otros archivos (.csv, .xlsx,…).\nAl tratarse de una estructura matricial, le es aplicable lo que hemos comentado sobre la indexación de matrices, pero veremos que para llamar a subconjuntos dentro del dataframe, podemos utilizar otros recursos y no solo un vector de posiciones.\nEn vez de hacerlo así, vamos a cargar datos que ya contiene R. R contiene muchos ejemplos de datos que van incluidos en las diferentes librerías y a los que podemos llamar.\nUno que se usa mucho para poner ejemplos es Iris que contiene información sobre tres especies de flores acompañadas de sus características (longitud y anchura de pétalos y sépalos).\nPara llamarlo basta con escribir esto:\n\ndata(iris) #basta con esto porque este dataset se incluye en la librería datasets que se instala por defecto en la instalación de base.\n\nSi quisiéramos llamar a un dataset contenido dentro de otro paquete, deberíamos hacerlo así.\n\ndata(Anscombe,package='carData') \n\nLa primera vez que cargamos unos datos de esta manera, en el entorno (pestaña Environment del panel superior derecho [si no se ha cambiado la colocación de los paneles en las opciones de RStudio]) aparecerá el nombre en el apartado ‘Values’ y al lado  junto con el resto de objetos que hemos ido creando.\n\nSi está en Promise, el dataset todavía no está cargado. Para que cargue hemos de llamarlo una primera vez.\n\nhead(iris) # solo pedimos los primeros registros (son 50)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\n\nhead(Anscombe) \n\n   education income young urban\nME       189   2824 350.7   508\nNH       169   3259 345.9   564\nVT       230   3072 348.5   322\nMA       168   3835 335.3   846\nRI       180   3549 327.1   871\nCT       193   4256 341.0   774\n\n\nY es entonces cuando pasa al conjunto Data.\n\nEn algunos ejemplos utilizaremos estos datos “precargados” en R, de ahí la explicación anterior, pero en general los datos serán importados desde archivos externos.\nComo comentábamos, el dataframe puede indexarse como hacíamos con la matriz.\nSolo columnas 2 y 3 de las primeras 6 filas. Las 6 filas las impone head por defecto. Sin usar head(), mostraría todas.\n\nhead(iris[,2:3])\n\n  Sepal.Width Petal.Length\n1         3.5          1.4\n2         3.0          1.4\n3         3.2          1.3\n4         3.1          1.5\n5         3.6          1.4\n6         3.9          1.7\n\n\nSeleccionamos los registros (ejemplares) 4 y 10, y las colunas 2 y 3 del datarame.\n\niris[c(4,10),2:3] #\n\n   Sepal.Width Petal.Length\n4          3.1          1.5\n10         3.1          1.5\n\n\nAl tratarse de un dataframe, podemos llamar a las columnas, en última instancia las variables contenidas en nuestro dataset, por su nombre. Para ello utilizaremos un vectore de cadenas de texto (character).\n\niris[c(4,10),c(\"Sepal.Width\",\"Sepal.Length\")]\n\n   Sepal.Width Sepal.Length\n4          3.1          4.6\n10         3.1          4.9\n\n\nOtra forma de llamar a una variable concreta es utilizando el carácter reservado $. Para ello comenzamos con el nombre del dataframe y separadmos el nombre de la variable mediante el símbolo del $.\nEn realidad esta forma de llamar a partes de un objeto (utilizando $ como separador), se utiliza también en otros objetos más complejos.\n\niris$Sepal.Length\n\n  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1\n [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0\n [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5\n [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1\n [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5\n [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3\n[109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2\n[127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8\n[145] 6.7 6.7 6.3 6.5 6.2 5.9\n\n\nEsto será muy útil para crear nuevas variables en el dataframe. Aunque lo veremos con más detenimiento en la siguiente sesión, incluyo aquí algún ejemplo básico porque ayuda a entender cómo funciona en el dataframe.\nPor ejemplo, imaginemos que deseamos crear la razón entre la longitud y la anchura de los sépalos.\n\niris$Sepal.Ratio <- iris$Sepal.Length/iris$Sepal.Width\n\nComo podemos observar, el dataframe iris contiene ahora una nueva variable llamada sepal.ratio.\n\niris[1:4,c(\"Sepal.Length\",\"Sepal.Width\",\"Sepal.Ratio\")] #limito el número de filas utilizando un vector como índice.\n\n  Sepal.Length Sepal.Width Sepal.Ratio\n1          5.1         3.5    1.457143\n2          4.9         3.0    1.633333\n3          4.7         3.2    1.468750\n4          4.6         3.1    1.483871\n\n\nPara eliminar una variable del data frame, basta con que asignemos NULL al vector correspondiente.\n\niris$Sepal.Ratio<-NULL\n\nUna vez hemos visto lo básico sobre cómo manejarse con un dataframe, en la siguiente sesión aprenderemos a importar uno.\n\n\n3.5.0.6 Listas.\nLa lista es un objeto que a pesar de su utilidad cuesta comprender cuando estás empezando a trabajar con R. En cierto modo es un contenedor porque puede almacenar otros objetos de diferente tipo (vectores, arrays, dataframes, gráficos) en su interior. Además, en muchas funciones, alguno de los argumentos es de tipo lista y muchas otras devuelven objetos de tipo lista.\n¿Se puede vivir sin comprender qué es una lista en R? Sí, pero no manejarse algo con ellas limita mucho tu crecimiento posterior. En un curso de iniciación como este, solo pondré un ejemplo para ilustrar su funcionamiento, pero no te preocupes si en este momento no comprendes del todo su funcionamiento.\nEn este ejemplo voy a generar un vector, una matriz, un dataframe y un gráfico5 y los voy a incluir en una lista.\nEn el ejemplo voy a utilizar funciones para generar vectores aleatorios siguiendo distribuciones de probabilidad teórica concretas (en el ejemplo una normal y una binomial). No es necesario entender su funcionamiento para comprender el ejemplo, basta con saber que crean vectores de 50 elementos que serán  las variables del dataframe simulado.\n\nv1 <- c('Juan', 'Pedro','Luisa')\nm1 <- matrix(c(3,5,7,22,45,76,25,22,21),ncol=3)\ndf1 <- data.frame(id=1001:1050,pas=round(rnorm(50,120,5)),sex=factor(rbinom(50,1,.35),labels=c('Hombre','Mujer')))\n\nplot.new()\nbarplot(table(df1$sex))\n\n\n\np1 <- recordPlot()\n\nlista1 <- list(v1,m1,df1,p1)\n\nSi analizamos su estructura, vemos que tiene cuatro elementos.\nUtilizo el argumento max.level para limitar la información que muestra sobre la lista. El tercer elemento es muy grande y si lo muestra entero ocuparía mucho espacio. De hecho, como se puede ver, ha convertido el gráfico en ¡otra lista!\n\nstr(lista1,max.level = 1) \n\nList of 4\n $ : chr [1:3] \"Juan\" \"Pedro\" \"Luisa\"\n $ : num [1:3, 1:3] 3 5 7 22 45 76 25 22 21\n $ :'data.frame':   50 obs. of  3 variables:\n $ :List of 3\n  ..- attr(*, \"engineVersion\")= int 16\n  ..- attr(*, \"pid\")= int 27576\n  ..- attr(*, \"Rversion\")=Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1\n  ..- attr(*, \"load\")= chr(0) \n  ..- attr(*, \"attach\")= chr(0) \n  ..- attr(*, \"class\")= chr \"recordedplot\"\n\n\nComo inica la estructura, es una lista de 4 elementos, el vector, una matriz 3x3, un dataframe de 50 observaciones y tres variables , y un cuarto elemento que es otra lista y que al ser llamado, devolverá el gráfico.\nUna vez creada, podemos acceder (llamar) a los elementos de la lista utilizando índices, pero las listas necesitan doble corchete ([[]]) para ser indexadas.\n\nlista1[[4]] #Esto llamaría al cuarto elemento de la lista, que era el gráfico.\n\n\n\n\nLos elementos de las listas pueden también tener nombres y ser llamados por ellos. Esta lista no los tiene, pero se le pueden asignar utilizando un simple vector (recordad que en R hay muchas estructuras vectoriales).\n\nnames(lista1) <- c('mi_vector','mi_matriz','mi_dataframe','mi_gráfico')#este vector asigna nombres a los elementos. Ha de ser de la misma longitud que el número de elementos.\n\nAhora podemos usar el nombre para llamar a los elementos de la lista, parecido a lo que hacíamos para llamar a las variables dentro de un dataframe.\n\nhead(lista1$mi_dataframe,n = 10) #Uso head con al argumento n=10 para que solo muestre las 10 primeras filas.\n\n     id pas    sex\n1  1001 130 Hombre\n2  1002 129  Mujer\n3  1003 119 Hombre\n4  1004 116 Hombre\n5  1005 118  Mujer\n6  1006 119  Mujer\n7  1007 120 Hombre\n8  1008 119  Mujer\n9  1009 116  Mujer\n10 1010 115 Hombre\n\n\n\n\n3.5.0.7 Funciones (un par de palabras)\nA lo largo de esta sesión, de manera más o menos consciente, habéis trabajado con funciones. Estas funciones están contenidas en las librerías que hemos mencionado al inicio de la sesión. Podemos generar nuestras propias funciones, pero en mi opinión es preferible introducir su creación en clases más avanzadas.\nAunque es cierto que cuando eres capaz de crear una función entiendes mejor su funcionamiento, no es necesario saber hacerlo para utilizarlas correctamente, pero sí es necesario comentar, aunque sea brevemente, su estructura.\nComo hemos comentado, cuando la librería está cargada (recordad que se cargan con la función library6), basta con llamar a la función para ejecutarla. Como habéis visto, el nombre de la función va seguido de unos paréntesis que contienen lo que llamamos “argumentos”. Los argumentos nos permiten personalizar la función al objetivo. Cada argumento tiene un nombre, y en muchos casos un valor por defecto. En el fondo la forma de llamar (ejecutar) la función se parece estructuralmente a un vector en el que cada elemento tiene un nombre y el valor de cada argumento es utilizado para ejecutar la función.\nEn muchos casos podemos ver el código detras de una función7. Por ejemplo, este sería el código que ejecuta la función ls()\n\nls #Para poder verlo he de ejecutar la función sin argumentos, sin el contenido de los paréntesis.\n\nfunction (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, \n    pattern, sorted = TRUE) \n{\n    if (!missing(name)) {\n        pos <- tryCatch(name, error = function(e) e)\n        if (inherits(pos, \"error\")) {\n            name <- substitute(name)\n            if (!is.character(name)) \n                name <- deparse(name)\n            warning(gettextf(\"%s converted to character string\", \n                sQuote(name)), domain = NA)\n            pos <- name\n        }\n    }\n    all.names <- .Internal(ls(envir, all.names, sorted))\n    if (!missing(pattern)) {\n        if ((ll <- length(grep(\"[\", pattern, fixed = TRUE))) && \n            ll != length(grep(\"]\", pattern, fixed = TRUE))) {\n            if (pattern == \"[\") {\n                pattern <- \"\\\\[\"\n                warning(\"replaced regular expression pattern '[' by  '\\\\\\\\['\")\n            }\n            else if (length(grep(\"[^\\\\\\\\]\\\\[<-\", pattern))) {\n                pattern <- sub(\"\\\\[<-\", \"\\\\\\\\\\\\[<-\", pattern)\n                warning(\"replaced '[<-' by '\\\\\\\\[<-' in regular expression pattern\")\n            }\n        }\n        grep(pattern, all.names, value = TRUE)\n    }\n    else all.names\n}\n<bytecode: 0x000001fcb9f7b928>\n<environment: namespace:base>\n\n\nAl principio el código es ininteligible, pero según vas aprendiendo, y especialmente cuando diseñas tus propias funciones, es cada vez más lógico, al fin y al cabo se trata de comunicarse con una máquina.\nPero lo que nos interesa es que comprendáis la gramática que esconde una función. Aquí la ayuda es de gran valor.\n\n ?ls #Pido ayuda sobre la función, por eso utilizo solo un ?\n\nAl ejecutarlo, debería aparecer algo como esto en la pestaña Help del panel inferior derecho (si no se ha cambiado la configuración predeterminada):\n\n\n\nEjemplo de ayuda sobre una función\n\n\nEl primer bloque, Description describe qué hace la función8.\nPero me interesa más que entendáis el segundo y tercer bloque Usage y Arguments. En el bloque Usage podéis ver una parte de lo que, con permiso de los puristas, llamaría gramática de R. Entre paréntesis, aparecen los nombres de los argumentos y, a veces, el valor por defecto9 Cuando no tiene valor por defecto es que no lo necesita obligatoriamente, pero si lo deseas puedes asignarle un valor para conseguir que la función opere con dicha especificación. ¿Cualquier valor? No. El tipo de valor que acoge(a veces es un objeto, como una matriz, un dataframe, un vector…)se explica en la sección Arguments.\nLo que viene ahora se explica poco, aunque se usa mucho, con frecuencia de manera inconsciente. Como os decía, estructuramente se parece mucho a un vector (en R, muchas estructuras son vectoriales), y como ocurre con los vectores, las posiciones son relevantes. Cada argumento tiene una posición reservada. Si la información que necesita el argumento se coloca en la posición reservada, la función interpreta el valor sin necesidad de que le indiques el nombre del argumento, porque está donde se le espera. Pero no es obligado darle los argumentos en orden, los puedes cambiar de lugar; eso sí, si los cambias de lugar, deberás indicarle a qué argumento te refieres, porque ya no está donde se le esperaba.\nPor ejemplo:\nEl argumento sorted está en la posición 5. Es un argumento lógico (TRUE/FALSE) que sirve pare decirle que ordene el resultado de la orden listar los objetos del espacio de trabajo.\nSi lo coloco en la posición en la que lo espera…\n\nls(,,,,,TRUE)\n\n [1] \"a1\"         \"a2\"         \"a2.1\"       \"a3\"         \"Anscombe\"  \n [6] \"ar\"         \"ar2\"        \"b\"          \"d\"          \"df1\"       \n[11] \"iris\"       \"lista1\"     \"m1\"         \"m2\"         \"p1\"        \n[16] \"v1\"         \"vecnam.rep\" \"x\"          \"y\"         \n\n\n… ordena por orden alfabético la lista de los objetos que hemos ido generando.\nLo mismo sucede si le hubiéramos indicado el nombre del argumento.\n\nls(sorted=TRUE)\n\n [1] \"a1\"         \"a2\"         \"a2.1\"       \"a3\"         \"Anscombe\"  \n [6] \"ar\"         \"ar2\"        \"b\"          \"d\"          \"df1\"       \n[11] \"iris\"       \"lista1\"     \"m1\"         \"m2\"         \"p1\"        \n[16] \"v1\"         \"vecnam.rep\" \"x\"          \"y\"         \n\n\nPero si le indico el valor del argumento sin el nombre del mismo, o sin colocarlo en la posición adecuada, sucede esto:\n\nls(TRUE)\n\nLa función cree que el valor TRUE es para el argumento name, que no es un argumento de tipo lógico (TRUE/FALSE).\nTodas las funciones de R funcionan así. Es raro que necesitemos utilizar todos los argumentos, por lo que en general acabaremos indicando el nombre y el valor solo de los argumentos necesarios para que la función haga lo que nosotros deseamos, sin embargo es frecuente encontrarse en los blogs de consulta, código en el que no se indica el argumento. Esta es la explicación.\nPara terminar este apartado sobre objetos, solo queda decir que hay muchos otros tipos de objetos, algunas funciones crean sus propios objetos, aunque con frecuencia contienen uno o más de los que hemos visto.\nEn la siguiente sesión veremos cómo importar datos para construir un dataframe y trasnformarlo para obtener nuevas variables."
  },
  {
    "objectID": "PR_2_lect.html",
    "href": "PR_2_lect.html",
    "title": "3  PR2-Importación de datos.",
    "section": "",
    "text": "4 Importación de datos en R.\nEn la sección anterior hemos visto lo fundamental sobre estructuras y hemos comentado las características de una estructura clave en el manejo de datos en R: dataframe.\nEn esta práctica vamos a ver cómo importar datos utilizando diferentes funciones dependiendo del origen.\nComo comentábamos, la importación consiste en construir un objeto, generalmente de tipo dataframe a partir de un archivo externo.\nPara hacerlo necesitamos que el archivo externo tenga una estructura matricial (.xlsx) o que pueda convertirse en matricial (.csv) porque incluya caracteres de separación que le indiquen al programa que lo importa, en nuestro caso R, cuando cambiamos de columna o de fila.\nSe han incorporado muchas funciones a R que realizan la importación de forma casi automática, pero entender sus fundamentos puede ayudar a entender y resolver problemas de importación.\nNos vamos a centrar en dos estructuras desde las que con frecuencia vamos a importar datos."
  },
  {
    "objectID": "PR_2_lect.html#guardar-los-datos-para-la-siguiente-sesión.",
    "href": "PR_2_lect.html#guardar-los-datos-para-la-siguiente-sesión.",
    "title": "3  PR2-Importación de datos.",
    "section": "4.1 Guardar los datos para la siguiente sesión.",
    "text": "4.1 Guardar los datos para la siguiente sesión.\nUna vez hemos trabajado los datos en R, no tendría mucho sentido volver a exportarlos con las nuevas variables creadas, salvo que deseemos enviárselo a alguien que no utilice R o no pueda importar su formato de datos.\nPodríamos guardar toda la imagen del espacio de trabajo (Workspace) y cargarla antes de trabajar con el nuevo dataframe en la siguiente sesión.\nSin embargo, y aunque cueste entenderlo al principio, es preferible guadar la menor cantidad de objetos posibles y tratar de que sea el código el que lo construya cada vez.\nSi el objeto es muy grande o lleva mucho tiempo volver a generarlo con código, puede estar justificado guardar el o los objetos concretos.\nEn el caso del dataframe tenemos una estructura de datos que le sirve a R para gestionar esta parte. Son los archivos .RDS.\nEn este vínculo explican las dos opciones, pero de momento prefiero utilizar un archivo .RDS. Solo necesita un par de argumentos, el nombre del objeto dataframe que queremos guardar y el nombre del archivo en el que queremos guardarlo.\nEl dataframe que nos interesa es iam, porque contiene las nuevas variables y las transformaciones que hemos realizado. Incluyo los nombres de los argumentos, pero dado que son los dos primeros en realidad no haría falta1.\n\nsaveRDS(object=iam,file='iam.RDS')\n\nEs importante que aprendáis a salvarlo (ahora y tras el capítulo de manipulación de datos), porque lo utilizaremos en futuras sesiones."
  },
  {
    "objectID": "PR_3_lect.html",
    "href": "PR_3_lect.html",
    "title": "4  PR3-Manipulación de datos.",
    "section": "",
    "text": "5 Importación y manipulación de datos en R.\nEn la sección anterior hemos visto cómo importar datos y como transformarlos usando base R.\nSi tienes problemas con la importación, echa un vistazo a las notas de la sesión anterior.\nEn esta sesión aprenderemos a manipular los datos para, por ejemplo, construir nuevas variables a partir de las originales. Lo haremos utilizando base R, pero también incluiremos al final cómo hacer lo mismo con modern R."
  },
  {
    "objectID": "PR_3_lect.html#importación-de-datos.",
    "href": "PR_3_lect.html#importación-de-datos.",
    "title": "4  PR3-Manipulación de datos.",
    "section": "5.1 Importación de datos.",
    "text": "5.1 Importación de datos.\nAntes de hablar de transformaciones, vamos a repasar las funciones que utilizamos para construir el dataframe.\n\niam<-read.csv('_data/myiam2.csv') # Utilizando relative path.\n\nRecuerde que la salidas de las funciones “read” suelen ser dataframes, y por ello podemos asignarlo directamente a un objeto, en el ejemplo el objeto (dataframe) llamado iam.\nPrimeras filas del dataframe.\n\nhead(iam)\n\n  Id      Age Sex Height Weight Smoke ami\n1  1 65.24100   1   1.62  74.56     0   0\n2  2 62.45461   0   1.56  60.89     0   0\n3  3 64.68328   0   1.69  74.20     0   0\n4  4 65.36045   0   1.34  43.92     0   0\n5  5 70.71094   0   1.81  80.86     1   0\n6  6 65.42030   0   1.78  80.56     0   0\n\n\nEstructura del dataframe (en realidad la puedes ver en la pestaña Environment del panel superior derecho [en esta configuración])\n\nstr(iam)\n\n'data.frame':   100 obs. of  7 variables:\n $ Id    : int  1 2 3 4 5 6 7 8 9 10 ...\n $ Age   : num  65.2 62.5 64.7 65.4 70.7 ...\n $ Sex   : int  1 0 0 0 0 0 1 0 0 0 ...\n $ Height: num  1.62 1.56 1.69 1.34 1.81 1.78 1.79 1.44 1.56 1.87 ...\n $ Weight: num  74.6 60.9 74.2 43.9 80.9 ...\n $ Smoke : int  0 0 0 0 1 0 0 1 0 0 ...\n $ ami   : int  0 0 0 0 0 0 0 1 0 0 ...\n\n\nRecuerde que esta estructura también está visible si desplegamos el dataframe en la pestaña Environment, ventana data del panel superior derecho.\n\n\n\nvent_data"
  },
  {
    "objectID": "PR_3_lect.html#manipulación-de-datos.",
    "href": "PR_3_lect.html#manipulación-de-datos.",
    "title": "4  PR3-Manipulación de datos.",
    "section": "5.2 Manipulación de datos.",
    "text": "5.2 Manipulación de datos.\nAntes de poder modificar variables existentes o crear algunas nuevas, necesitamos conocer algunas funciones y operadores básicos incluidos en la instalación básica de r.\n\n5.2.1 Operadores.\n\n\n\nOperadores comparativos\nSímbolo/instrucción\n\n\n\n\nigualdad\n==\n\n\ndesigualdad\n!=\n\n\nmenor\n<\n\n\nmenor igual\n<=\n\n\nmayor\n>\n\n\nmaryor igual\n>=\n\n\n\n\n\n\nOperadores lógicos\nSímbolo/instrucción\n\n\n\n\nAND lógica\n&\n\n\nOR lógica\n|\n\n\nnegación lógica\n!\n\n\nIdentidad\n&&\n\n\n\n\n\n5.2.2 Funciones básicas.\n\n\n\nOperador/Función\nSímbolo/instrucción\n\n\n\n\nsuma\n+\n\n\nresta\n-\n\n\nmultiplicación\n*\n\n\ndivisión\n/\n\n\nmódulo\n%% (resto de división)\n\n\ndivisión entera\n%/%\n\n\nraíz cuadrada\nsqrt\n\n\nlogaritmo natural (base e)\nlog\n\n\nlogaritmos genérico (base->b)\nlogb (ex. log10(45))\n\n\nnúmero e elevado a x\nexp(x)\n\n\nmáximo\nmax\n\n\nmínimo\nmin\n\n\nrango\nrange\n\n\nlongitud\nlength\n\n\nsumatorio\nsum\n\n\nproductorio\nprod\n\n\nmedia\nmean\n\n\nmediana\nmedian\n\n\ndesv. estándar\nsd\n\n\nvarianza\nvar\n\n\n\n\n\n5.2.3 Manipulaciones más frecuentes.\nSeguiremos utilizando el dataframe generado anteriormente llamado iam.\n\n5.2.3.1 Recodificar en base a puntos de corte. (Convertir numérica en factor)\nLa función cut es muy útila para generar una variable categórica a partir de una cuantitativa discreta o continua. Solo necesitas que le entregemos el vector a cortar y los puntos de corte. Veamos un par de ejemplos.\nConstruiremos grupos de edad e intervalos de 10 años. El máximo de esta variable es 70.71 y el mínimo es 59.5, así pues nos hacen falta puntos de corte entre ambos valores con amplitud de 10 años.\n\niam$age5<-cut(iam$Age,seq(55,75,10),include.lowest = T,right = T) # la función seq nos facilita la tarea de construir el vector de puntos de corte.\n\nLa propia función genera un factor (ya hablaremos de este tipo de objetos que servirán para almacenar variables categóricas )\nPodemos construir una tabla para comprobar la distribución de la nueva variable categórica.\n\ntable(iam$age5)\n\n\n[55,65] (65,75] \n     47      53 \n\n\nComo se puede observar, la propia función genera las etiquetas de los intervalos en función de los puntos de corte que le hemos dado. A tener en cuenta:\n* La función *cut* tiene argumentos para poder construir los intervalos cerrando el intervalo por su límite derecho (argumento right=T) .\n* la función *cut* genera un objeto de tipo vector y de clase factor, por lo que sus etiquetas de nivel se pueden modificar (lo veremos al hablar de factores).\n* la función *cut* puede cerrar el intervalo inferior (argumento include.lowest=T)\n\n\n5.2.3.2 Construir variables operando otras.\nEn el dataframe iam se incluyen las variables peso y altura. Vamos a construir el Índice de Masa Corporal.\n\\[IMC=\\frac{Peso (kg)}{Altura(m)^2}\\]\n\niam$bmi<-iam$Weight/iam$Height^2\n\nComo se puede observar, para incluirla en el dataframe, hemos de indicárselo utilizando el nombre del mismo seguido de $ y el nombre que queremos dar a la nueva variable, en este caso bmi.\n\n\n5.2.3.3 Recodificación.\nPosiblemente una de las tareas más frecuentes, si no la más frecuente, manipulando datos es la recodificación, construir una variable categórica agrupando categorías de otra.\nPara entender esta tarea en R, es útil entender la clase factor, la clase en la que vamos a almacenar las variables categóricas.\n\n\n5.2.3.4 Factores ¿Qué es un factor en R?\nLos factores son posiblemente uno de los elementos básicos en R que más cuesta entender. En mi opinión tiene que ver con la confusión entre el concepto de nivel (level) y la etiqueta (label) que se le asigna a cada uno de los niveles.\nPara explicar cómo funciona, vamos a crear un ejemplo sencillo para ver cómo operan estas dos características.\nAunque parezca extraño, vamos a partir de un vector de tipo integer para posteriormente convertirlo en uno de tipo factor al que añadiremos las etiquetas.\n\nConstrucción de un vector numérico.\n\n\nx<-rep(0:1,25)\n\n\nConversión del vector en un factor, sin decirle nada más.\n\n\nsex<-factor(x)\n\n\nAl utilizar la función factor, R lee el vector que recibe y, si no le decimos otra cosa, identifica los valores diferentes y los ordena en orden alfanumérico.\nActo seguido va asignado el nivel correspondiente a cada valor diferente, y utiliza el valor original para construir una etiqueta.\nLo que obtenemos es un vector de tipo factor que tiene niveles que van del 1 al número de valores diferentes que trajese la variable (el vector) original. Pero estos niveles están ocultos detrás de las etiquetas que se les asignan.\nLo importante es el nivel, pero su relación con la etiqueta asignada nos va a permitir recodificar variables utilizando las etiquetas que se les asignan.\n\nVeamos un ejemplo.\nEl vector sex, creado con el código anterior, tiene dos niveles, 1 y 2, pero las etiquetas que fueron asignadas como indiqué, son “0” y “1”, valores originales del vector. Al no decirle lo contrario, usó el orden alfanumérico, por eso el 0 se asigna al primer nivel y el 1 al segundo nivel.\nSi queremos ver los auténticos niveles que contiens podemos forzar una conversión de tipo de la siguiente manera:\n\nsex\n\n [1] 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\n[39] 0 1 0 1 0 1 0 1 0 1 0 1\nLevels: 0 1\n\nas.numeric(sex)\n\n [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n[39] 1 2 1 2 1 2 1 2 1 2 1 2\n\n\nObserve como el primer vector muestra las etiquetas, mientras que el segundo muestra los niveles.\nEn realidad podríamos haber impuesto nuestras etiquetas a dichos niveles en la propia creación del factor, pero para eso debemos entender que si no le decimos lo contrario, la identificación del orden de asignación sigue dependiendo del orden alfanumérico.\nPara indicarle las etiquetas, basta con meter un vector con las etiquetas en el argumento labels.\nEn este ejemplo asumimos que el 0 es el valor con el que en la base de datos original se codificó Hombre y 1 el valor con el que se codificó Mujer.\n\nsex2<-factor(x,labels = c('Hombre','Mujer'))\n\n\nsex2\n\n [1] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[11] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[21] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[31] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[41] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \nLevels: Hombre Mujer\n\nas.numeric(sex2)\n\n [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n[39] 1 2 1 2 1 2 1 2 1 2 1 2\n\n\nComo se puede observar, los niveles (1 y 2) siguen siendo los mismos, pero las etiquetas han cambiado.\nTambién se obseva como cuando pedimos un vector de clase factor, debajo aparecen los niveles (Levels: Hombre Mujer) en el orden en que se asignan a los niveles subyacentes (1 y 2).\nImaginemos que por alguna razón hubiésemos querido que el primer nivel se asignase a Mujer aunque el código que se asignó en la base de datos original fue el superior (1). Podemos obligar a que la función lea los niveles como nosotros deseemos usando el argumento levels.\n\nLa posición que asignemos a los niveles tendrá importancia en la construcción de los modelos, puesto que, aunque se puede cambiar, la comparación que se establece por defecto es contra el nivel más bajo, que funcionará como nivel de referencia.\n\n\nsex3<-factor(x,levels=c(\"1\",\"0\"))\n\n\nsex3\n\n [1] 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\n[39] 0 1 0 1 0 1 0 1 0 1 0 1\nLevels: 1 0\n\nas.numeric(sex3)\n\n [1] 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1\n[39] 2 1 2 1 2 1 2 1 2 1 2 1\n\n\nAhora los ceros (hombres), han sido asignados al nivel 2 y los unos (mujeres al nivel 1). Por supuesto podríamos haber colocado nuestras etiquetas en la propia creación, pero debemos tener en cuenta que hemos impuesto un nuevo orden a los niveles.\n\nsex4<-factor(x,levels=c(\"1\",\"0\"),labels=c('Women','Men'))\nsex4\n\n [1] Men   Women Men   Women Men   Women Men   Women Men   Women Men   Women\n[13] Men   Women Men   Women Men   Women Men   Women Men   Women Men   Women\n[25] Men   Women Men   Women Men   Women Men   Women Men   Women Men   Women\n[37] Men   Women Men   Women Men   Women Men   Women Men   Women Men   Women\n[49] Men   Women\nLevels: Women Men\n\nas.numeric(sex4)\n\n [1] 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1\n[39] 2 1 2 1 2 1 2 1 2 1 2 1\n\n\nLa informacion contenida en el vector no ha cambiado (donde había un Hombre ahora también, aunque con la etiqueta Men), pero el nivel asignado sí lo ha hecho.\n¿Cómo saber los niveles que tiene un factor?\nMediante la función levels.\n\nlevels(sex4)\n\n[1] \"Women\" \"Men\"  \n\n\nComo se puede observar, esta función devuelve un vector. Pues bien, podemos modificar dicho vector para cambiar las etiquetas del factor, siempre que tengamos claro el orden de los niveles.\n\nlevels(sex4)<-c('Mujer','Hombre')\nsex4\n\n [1] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[11] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[21] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[31] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[41] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \nLevels: Mujer Hombre\n\n\nEs más, esta función nos permite recodificar los niveles de manera fácil como veremos posteriormente.\nPodemos crear factores a partir de cualquier tipo de vector. De hecho, con frecuencia este vector es de tipo character, es decir que trae “puesta” la etiqueta.\nSí así fuera, basta con utilizar la función factor par construir el vector. Veamos un ejemplo.\nConstruiremos un vector de tipo character.\n\nnse<-c(rep('NSE1',10),rep('NSE2',4),rep('NSE3',12),rep('NSE4',5))\n# hay formas más elegantes de construir este vector, pero hacen falta funciones que aún no hemos visto.\n\nComo se puede ver, las palabras contenidas en el vector están entre comillas, lo que señala que se trata de cadenas de caracteres.\nConversión en factor asumiendo el orden alfanumérico de los valores diferentes dentro del vector.\n\nnse_f<-factor(nse)\nnse_f\n\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2 NSE2 NSE2 NSE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE1 NSE2 NSE3 NSE4\n\n\nComo se puede observar, la conersión en factor hace que tenga niveles (Levels: NSE1 NSE2 NSE3 NSE4) cuyo orden ha sido establecido por el orden alfanumérico de las cadenas de caracteres que contenía el vector.\nPara que se entienda cómo actúa la conversión, vamos a construir un vector parecido pero en el que una de las cadenas no sigue el patrón NSE.\n\nnse2<-c(rep('NSE1',10),rep('SNE2',4),rep('NSE3',12),rep('NSE4',5))\nnse2\n\n [1] \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\"\n[11] \"SNE2\" \"SNE2\" \"SNE2\" \"SNE2\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\"\n[21] \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE4\" \"NSE4\" \"NSE4\" \"NSE4\"\n[31] \"NSE4\"\n\n\nEste vector es parecido al nse, solo cambia la cadena de 4 elementos, que ahora es SNE2 en vez de NSE2.\nAl transformarlo en factor:\n\nnse2_f<-factor(nse2)\nnse2_f\n\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 SNE2 SNE2 SNE2 SNE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE1 NSE3 NSE4 SNE2\n\n\n…podemos ver como SNE2 se ha colocado en el cuarto nivel, que es el que le corresponde al ordenar alfabéticamente los niveles diferentes (valores diferentes en el contenido) detectados por la función.\nEsto no afecta a la información en sí misma, pues la etiqueta signada al nivel 4 estará allá donde el vector de caracteres incluyera “SNE2”.\nEn realidad podríamos haberlo evitado indicando la colocación de los niveles.\n\nnse2_f2<-factor(nse2,levels = c('NSE1','SNE2','NSE3','NSE4'))\nnse2_f2\n\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 SNE2 SNE2 SNE2 SNE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE1 SNE2 NSE3 NSE4\n\n\n\n\n5.2.3.5 Recodificación.\nLa recodificación es fácil cuando se hace sobre el factor, porque basta con reasignar las etiquetas a los niveles. Esta relación entre levels y labels es la que, en mi opinión, genera más confusión a la hora de entender los factores.\nVamos a recodificar el vector nse_f (el primer factor que generamos) agrupando los niveles 2 y 3.\n\n#Crearemos una copia para no perder el anterior y poder comparar los efectos.\nnse_f_rec<-nse_f \nnse_f_rec #Vemos que es el mismo vector.\n\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2 NSE2 NSE2 NSE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE1 NSE2 NSE3 NSE4\n\nlevels(nse_f_rec) #Preguntamos por los niveles.\n\n[1] \"NSE1\" \"NSE2\" \"NSE3\" \"NSE4\"\n\nas.numeric(nse_f_rec) # visualizamos los niveles subyacentes.\n\n [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4\n\n\nCambiamos los niveles actuando sobre las etiquetas de nivel. Confunde, porque parece que solo estamos cambiando la etiqueta y que por debajo permanecerán los cuatro niveles, pero…\n\nlevels(nse_f_rec)<-c('NSE1','NSE2_3','NSE2_3','NSE4')  \nlevels(nse_f_rec) # No solo son tres etiquetas.\n\n[1] \"NSE1\"   \"NSE2_3\" \"NSE4\"  \n\nas.numeric(nse_f_rec)\n\n [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3\n\n\nPodemos ver cómo ha ido la recodificación construyendo una tabla de contingencia con los dos vectores.\n\ntable(nse_f_rec,nse_f)\n\n         nse_f\nnse_f_rec NSE1 NSE2 NSE3 NSE4\n   NSE1     10    0    0    0\n   NSE2_3    0    4   12    0\n   NSE4      0    0    0    5\n\n\n\nEs importante tener en cuenta que esta acción ya no puede ser deshecha; no podemos volver al vector que los tenía separados si no contamos con el original o versiones previas del que hemos destruido al generar el nuevo.\n\nPor un método parecido podemos reordenar los niveles para que el nivel de referencia sea el que deseemos.\nEn el siguiente ejemplo vamos a conseguir que sea el NSE4 el nivel de referencia.\n\nnse_f_rec<-relevel(nse_f_rec,ref = 'NSE4') # Para entregárselo, de nuevo le indicamos la etiqueta de nivel.\nnse_f_rec\n\n [1] NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1  \n[11] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3\n[21] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE4   NSE4   NSE4   NSE4  \n[31] NSE4  \nLevels: NSE4 NSE1 NSE2_3\n\n\nEn realidad podríamos haberlo conseguido con la propia función factor.\n\nfactor(nse_f_rec,levels=c('NSE1','NSE2_3','NSE4')) # no lo asignamos al objeto para poder seguir utilizándolo posteriormente.\n\n [1] NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1  \n[11] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3\n[21] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE4   NSE4   NSE4   NSE4  \n[31] NSE4  \nLevels: NSE1 NSE2_3 NSE4\n\n\nEs importante introducir bien las etiquetas porque de lo contario asignara NA (missing). Un ejemplo introduciendo un error en la primera etiqueta.\n\nfactor(nse_f_rec,levels=c('NSE','NSE2_3','NSE4')) # no lo asignamos al objeto para poder seguir utilizándolo posteriormente.\n\n [1] <NA>   <NA>   <NA>   <NA>   <NA>   <NA>   <NA>   <NA>   <NA>   <NA>  \n[11] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3\n[21] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE4   NSE4   NSE4   NSE4  \n[31] NSE4  \nLevels: NSE NSE2_3 NSE4\n\n\nPara facilitar la tarea hemos utilizado la función factor para “contener” una variable ordinal. En realidad R tiene una función específica para este tipo de factores ordenados (función ordered, o también función factor con argumento ‘ordered=T’), y algunas funciones son capaces de “entender” que se trata de una categórica ordinal y tratarla como tal.\nEn cualquier caso no es esencial y se puede hacer que la función lo entienda como ordinal utilizando otras opciones al construir el modelo.\nComo lo hemos mencionado, insertaré aquí un ejemplo de esta función.\n\nordered(nse)\n\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2 NSE2 NSE2 NSE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE1 < NSE2 < NSE3 < NSE4\n\nnse_of<-factor(nse,ordered = T)\n\nComo se observa, Levels indica la relación entre niveles, y podemos utilizarlos para darle la vuelta a la relación de los niveles del factor.\n\nfactor(nse,levels=c('NSE4','NSE3','NSE2','NSE1'),ordered = T)\n\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2 NSE2 NSE2 NSE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE4 < NSE3 < NSE2 < NSE1\n\n\nTodo esto está realizado con funciones básicas de R, lo que llamamos base R. En la realidad, se utiliza lo que se ha dado en llamar modern R, que automatiza y amplía las posibilidades de estas operaciones de gestión de datos.\nSin embargo, en mi experiencia, no entender cómo piensa R (indexación de vectores, matrices y dataframes, utilización de factores, tipos de vector…), hace más difícil resolver los problemas que surjan al utilizar enfoques más eficientes (modern R), pero más complejos.\nAlgo semejante pasará con los gráficos. R base construye buenos gráficos, y aunque permiten mucha personalización, hacerlo conlleva mucho código. El paquete ggplot2 facilita mucho la tarea de construcción de gráficos una vez se entiende ‘the Grammar of Graphics’ pero, para aprovechar su potencial al máximo, es útil entender como crear gráficos sencillos en R base, aunque debo reconocer que no todos los que nos dedicamos a la enseñanza estamos de acuerdo en esta cuestión."
  },
  {
    "objectID": "PR_3_lect.html#guardar-los-datos-para-la-siguiente-sesión.",
    "href": "PR_3_lect.html#guardar-los-datos-para-la-siguiente-sesión.",
    "title": "4  PR3-Manipulación de datos.",
    "section": "5.3 Guardar los datos para la siguiente sesión.",
    "text": "5.3 Guardar los datos para la siguiente sesión.\nUna vez hemos trabajado los datos en R, no tendría mucho sentido volver a exportarlos con las nuevas variables creadas, salvo que deseemos enviárselo a alguien que no utilice R o no pueda importar su formato de datos.\nPodríamos guardar toda la imagen del espacio de trabajo (Workspace) y cargarla antes de trabajar con el nuevo dataframe en la siguiente sesión.\nSin embargo, y aunque cueste entenderlo al principio, es preferible guadar la menor cantida de objetos posibles y tratar de que sea el código el que lo construya cada vez. Si el objeto es muy grande o lleva mucho tiempo volver a generarlo con código, puede estar justificado guardar el o los objetos concretos.\nEn el caso del dataframe tenemos una estructura de datos que le sirve a R para gestionar esta parte. Son los archivos .RDS.\nEn este vínculo explican las dos opciones, pero de momento prefiero utilizar un archivo .RDS. Solo necesita un par de argumentos, el nombre del objeto dataframe que queremos guardar y el nombre del archivo en el que queremos guardarlo.\nEl dataframe que nos interesa es iam, porque contiene las nuevas variables y las transformaciones que hemos realizado. Incluyo los nombres de los argumentos, pero dado que son los dos primeros en realidad no haría falta1.\n\nsaveRDS(object=iam,file='iam.RDS')\n\nEs importante que lo salvéis, porque lo cargaremos en la siguiente sesión. Así no tendremos que volver a generar todas las funciones de nuevo."
  },
  {
    "objectID": "PR_4_lect.html",
    "href": "PR_4_lect.html",
    "title": "5  PR4-Estadística Descriptiva.",
    "section": "",
    "text": "6 Estadística descriptiva con R.\nEn la sección anterior hemos visto como importar y gestionar variables de un dataframe. En esta práctica vamos a ver cómo obtener los descriptivos básicos. Es lo que se llama Análisis Exploratorio de los Datos (Exploratory Data Analysis [EDA])\nLo primero que debemos hacer es cargar los datos de iam que habíamos importado y modificado en la sesión anterior.\nNo indico ruta porque estoy en el directorio de trabajo y es donde está el archivo.\nSi no fuese así, debería indicar la ruta entre las comillas. Por ejemplo, si estuviese en un subdirectorio del de trabajo, debería hacerlo así.\nEste código debería devolveros un error salvo que efectivamnte hayáis colocado el archivo en ese subdirectorio1"
  },
  {
    "objectID": "PR_4_lect.html#descriptivo-inicial-y-depuración.",
    "href": "PR_4_lect.html#descriptivo-inicial-y-depuración.",
    "title": "5  PR4-Estadística Descriptiva.",
    "section": "6.1 Descriptivo inicial y depuración.",
    "text": "6.1 Descriptivo inicial y depuración.\nEntre los objetivos del llamado Análisis Exploratorio de los Datos (EDA o Exploratory Data Analysis) destacaría tres:\n\nObtener una visión general de la distribución de tus variables tanto mediante los descriptivos como los gráficos adecuados para el tipo de variable.\nDetectar valores anómalos por ser extremos (outliers), por no constar (missing) o por ser imposibles (error de medida o de introducción).\nVisualizar relaciones bivariadas (también hay técnicas multivariadas, pero no las veremos en esta introducción) entre las variables del dataframe.\nUna vez identificado todo lo anterior, podremos construir una primera foto de nuestra muestra.\n\nRespecto a los valores anómalos, a veces podrán ser eliminados (errores de introducción), pero en otras ocasiones tendremos que lidiar con ellos en la construcción de los modelos y en la presentación de los resultados.\nAunque no es una regla exacta, se suele decir que no te puedes fiar de una variable que tenga más de un 10% de valores perdidos (missing), pero en ocasiones no te queda más remedio que utilizarlas. En estos casos hay diversas técnicas de imputación de valores perdidos que escapan a los objetivos de este curso.\nComo habremos visto durante la clase, los descriptivos y gráficos adecuados dependen de la escala de medida de la variable a describir.\nR tiene algunos criterios para decidir que devolver cuando le pedimos que haga un resumen (función summary), pero para ello necesita que la variable sea de la clase adecuada (numéric, integer, logical, factor)\nUtilizaremos el dataframe iam. Recordemos su estructura.\n\nstr(iam)\n\n'data.frame':   100 obs. of  9 variables:\n $ Id    : int  1 2 3 4 5 6 7 8 9 10 ...\n $ Age   : num  65.2 62.5 64.7 65.4 70.7 ...\n $ Sex   : int  1 0 0 0 0 0 1 0 0 0 ...\n $ Height: num  1.62 1.56 1.69 1.34 1.81 1.78 1.79 1.44 1.56 1.87 ...\n $ Weight: num  74.6 60.9 74.2 43.9 80.9 ...\n $ Smoke : int  0 0 0 0 1 0 0 1 0 0 ...\n $ ami   : int  0 0 0 0 0 0 0 1 0 0 ...\n $ age5  : Factor w/ 2 levels \"[55,65]\",\"(65,75]\": 2 1 1 2 2 2 2 1 1 2 ...\n $ bmi   : num  28.4 25 26 24.5 24.7 ...\n\n\nComo se puede apreciar, algunas variables que deberían ser categóricas están como tipo entero (int o integer), así que lo primero que vamos a hacer es convertirlas en factores.\n\niam$Sex<-factor(iam$Sex,labels=c('Men','Women'))\n\nPodríamos ir cambiando una a una, pero R cuenta con algunas funciones que permiten cambiar simultáneamente varias variables que se van a etiquetar de la misma manera. En nuestro caso son ami (Acute Myocardial Infarction) y Smoke (Fuma sí/no) que van con 0 (No) y 1 (Yes).\nEs recomendable utilizar una estrategia homogénea de etiquetado de valores de variable para facilitar conversiones posteriores.\nLa familia de funciones apply (apply, lapply, sapply, tapply, mapply…) no son demasiado intuitivas, y se han desarrollado funciones que permiten realizar los mismo ocn código más intuitivo. Aunque incluya aquí un ejemplo, no es esencial conocerlas para poder realizar este tipo de modificación.\n\niam[,c('ami','Smoke')]<-lapply(iam[,c('ami','Smoke')],factor,labels=c('No','Yes'))\nstr(iam)\n\n'data.frame':   100 obs. of  9 variables:\n $ Id    : int  1 2 3 4 5 6 7 8 9 10 ...\n $ Age   : num  65.2 62.5 64.7 65.4 70.7 ...\n $ Sex   : Factor w/ 2 levels \"Men\",\"Women\": 2 1 1 1 1 1 2 1 1 1 ...\n $ Height: num  1.62 1.56 1.69 1.34 1.81 1.78 1.79 1.44 1.56 1.87 ...\n $ Weight: num  74.6 60.9 74.2 43.9 80.9 ...\n $ Smoke : Factor w/ 2 levels \"No\",\"Yes\": 1 1 1 1 2 1 1 2 1 1 ...\n $ ami   : Factor w/ 2 levels \"No\",\"Yes\": 1 1 1 1 1 1 1 2 1 1 ...\n $ age5  : Factor w/ 2 levels \"[55,65]\",\"(65,75]\": 2 1 1 2 2 2 2 1 1 2 ...\n $ bmi   : num  28.4 25 26 24.5 24.7 ...\n\n\nComo podemos observar, en la nueva estructura (hemos modificado el dataframe) las variables que antes eran de tipo entero, ahora son factores.\nSi ahora pedimos un primer resumen, observamos una serie de descriptivos básicos.\n\nsummary(iam)\n\n       Id              Age           Sex         Height          Weight      \n Min.   :  1.00   Min.   :59.50   Men  :58   Min.   :1.150   Min.   : 30.31  \n 1st Qu.: 25.75   1st Qu.:63.73   Women:42   1st Qu.:1.580   1st Qu.: 64.77  \n Median : 50.50   Median :65.24              Median :1.705   Median : 77.36  \n Mean   : 50.50   Mean   :65.14              Mean   :1.683   Mean   : 74.62  \n 3rd Qu.: 75.25   3rd Qu.:66.70              3rd Qu.:1.790   3rd Qu.: 82.59  \n Max.   :100.00   Max.   :70.71              Max.   :1.960   Max.   :121.87  \n Smoke     ami          age5         bmi       \n No :60   No :50   [55,65]:47   Min.   :17.09  \n Yes:40   Yes:50   (65,75]:53   1st Qu.:24.25  \n                                Median :25.42  \n                                Mean   :26.05  \n                                3rd Qu.:27.81  \n                                Max.   :33.01  \n\n\nEl paquete psych ofrece más posibilidades. Recuerde que si no lo tienen instalado debe instalarlo antes de llamar al paquete.\n\npsych::describe(iam)\n\n       vars   n  mean    sd median trimmed   mad   min    max range  skew\nId        1 100 50.50 29.01  50.50   50.50 37.06  1.00 100.00 99.00  0.00\nAge       2 100 65.14  2.09  65.24   65.15  2.23 59.50  70.71 11.21 -0.04\nSex*      3 100  1.42  0.50   1.00    1.40  0.00  1.00   2.00  1.00  0.32\nHeight    4 100  1.68  0.16   1.71    1.69  0.16  1.15   1.96  0.81 -0.72\nWeight    5 100 74.62 16.79  77.36   74.86 12.53 30.31 121.87 91.56 -0.11\nSmoke*    6 100  1.40  0.49   1.00    1.38  0.00  1.00   2.00  1.00  0.40\nami*      7 100  1.50  0.50   1.50    1.50  0.74  1.00   2.00  1.00  0.00\nage5*     8 100  1.53  0.50   2.00    1.54  0.00  1.00   2.00  1.00 -0.12\nbmi       9 100 26.05  3.14  25.42   25.86  2.02 17.09  33.01 15.93  0.35\n       kurtosis   se\nId        -1.24 2.90\nAge       -0.32 0.21\nSex*      -1.92 0.05\nHeight     0.43 0.02\nWeight     0.47 1.68\nSmoke*    -1.86 0.05\nami*      -2.02 0.05\nage5*     -2.01 0.05\nbmi        0.41 0.31\n\n\nDesgraciadamente, aunque identifica las variables categóricas, utiliza el valor numérico subyacente. Fíjese en la media de la variable Sex (1.42).\nA no olvidar:\n\nEchar un vistazo al mínimo y máximo. Esto nos permite detectar valores imposibles (por ejemplo una edad de 130 años, o un peso de 999).\nIdentificar si hay valores perdidos.\nEstadísticos que nos dan una primera visión sobre la distribución.\n\nCercanía de la media a la mediana, desviación típica (recuerde que el coeficiente de variación es \\(\\frac{sd}{\\overline{x}})\\) expresado en %).\nMedia recortada (trimmed, por defecto recorta el 10%) nos permite evaluar la influencia de los valores extremos.\nAsimetría (Skewness) y curtosis (Kurtosis) que nos permiten evaluar su parecido con una distribución normal, aunque solo con la estimación no es suficiente para llegar a una conclusión.\nMAD o Median Absolute Deviation, una medida robusta de la variabilidad que no es más que la mediana de los valores absolutos de distancias de cada valor a la mediana del conjunto. \\(MAD=median([X_i-median{X}])\\). b\nTambién aparece el error estándar (standard error o \\(se(X)\\)) que como veremos es importante en inferencia y que no se debe confundir con la desviación típica (standar deviation o \\((sd)\\)).\nNo aparecen por defecto pero se pueden solicitar los cuartiles, en realidad los percentiles que deseemos. Recuerde que estas son medidas de posición, que también ayudan a describir nuestros datos.\n\n\n\npsych::describe(iam,quant=c(.1,.25,.5,.75,.9))\n\n       vars   n  mean    sd median trimmed   mad   min    max range  skew\nId        1 100 50.50 29.01  50.50   50.50 37.06  1.00 100.00 99.00  0.00\nAge       2 100 65.14  2.09  65.24   65.15  2.23 59.50  70.71 11.21 -0.04\nSex*      3 100  1.42  0.50   1.00    1.40  0.00  1.00   2.00  1.00  0.32\nHeight    4 100  1.68  0.16   1.71    1.69  0.16  1.15   1.96  0.81 -0.72\nWeight    5 100 74.62 16.79  77.36   74.86 12.53 30.31 121.87 91.56 -0.11\nSmoke*    6 100  1.40  0.49   1.00    1.38  0.00  1.00   2.00  1.00  0.40\nami*      7 100  1.50  0.50   1.50    1.50  0.74  1.00   2.00  1.00  0.00\nage5*     8 100  1.53  0.50   2.00    1.54  0.00  1.00   2.00  1.00 -0.12\nbmi       9 100 26.05  3.14  25.42   25.86  2.02 17.09  33.01 15.93  0.35\n       kurtosis   se  Q0.1 Q0.25  Q0.5 Q0.75  Q0.9\nId        -1.24 2.90 10.90 25.75 50.50 75.25 90.10\nAge       -0.32 0.21 62.53 63.73 65.24 66.70 68.12\nSex*      -1.92 0.05  1.00  1.00  1.00  2.00  2.00\nHeight     0.43 0.02  1.47  1.58  1.71  1.79  1.86\nWeight     0.47 1.68 53.96 64.77 77.36 82.59 93.47\nSmoke*    -1.86 0.05  1.00  1.00  1.00  2.00  2.00\nami*      -2.02 0.05  1.00  1.00  1.50  2.00  2.00\nage5*     -2.01 0.05  1.00  1.00  2.00  2.00  2.00\nbmi        0.41 0.31 23.20 24.25 25.42 27.81 31.30\n\n\nCon frecuencia necesitamos obtener los descriptivos en función de los grupos que establezca una variable categórica. Para ello podemos recurrir a la función by, en la que indicamos cotjunto de datos a describir (argumento en posición 1), índice o variable que establece los grupos (argumento en posición 2) y función que queremos aplicar a cada grupo establecido por la funcion índice sobre las variables incluidas en el objeto que contiene los datos iam.\nNo todas las funciones son aceptadas por by, pero psych::describe si lo es.\n\nby(iam,iam$Sex,psych::describe)\n\niam$Sex: Men\n       vars  n  mean    sd median trimmed   mad   min    max range  skew\nId        1 58 49.64 30.61  48.50   49.50 40.03  2.00 100.00 98.00  0.05\nAge       2 58 65.15  2.07  65.28   65.12  2.03 60.89  70.71  9.82  0.18\nSex*      3 58  1.00  0.00   1.00    1.00  0.00  1.00   1.00  0.00   NaN\nHeight    4 58  1.67  0.16   1.70    1.69  0.17  1.15   1.87  0.72 -1.07\nWeight    5 58 70.31 12.45  75.19   71.70 10.51 30.31  84.79 54.48 -1.01\nSmoke*    6 58  1.31  0.47   1.00    1.27  0.00  1.00   2.00  1.00  0.80\nami*      7 58  1.34  0.48   1.00    1.31  0.00  1.00   2.00  1.00  0.64\nage5*     8 58  1.52  0.50   2.00    1.52  0.00  1.00   2.00  1.00 -0.07\nbmi       9 58 24.96  1.10  24.68   24.94  1.16 22.92  27.88  4.97  0.32\n       kurtosis   se\nId        -1.36 4.02\nAge       -0.33 0.27\nSex*        NaN 0.00\nHeight     1.07 0.02\nWeight     0.55 1.63\nSmoke*    -1.38 0.06\nami*      -1.62 0.06\nage5*     -2.03 0.07\nbmi       -0.56 0.14\n------------------------------------------------------------ \niam$Sex: Women\n       vars  n  mean    sd median trimmed   mad   min    max range  skew\nId        1 42 51.69 26.97  53.50   51.74 31.88  1.00  99.00 98.00 -0.06\nAge       2 42 65.13  2.14  65.19   65.19  2.36 59.50  68.63  9.13 -0.32\nSex*      3 42  2.00  0.00   2.00    2.00  0.00  2.00   2.00  0.00   NaN\nHeight    4 42  1.70  0.16   1.72    1.70  0.16  1.39   1.96  0.57 -0.27\nWeight    5 42 80.58 20.06  80.74   81.40 16.12 36.92 121.87 84.95 -0.37\nSmoke*    6 42  1.52  0.51   2.00    1.53  0.00  1.00   2.00  1.00 -0.09\nami*      7 42  1.71  0.46   2.00    1.76  0.00  1.00   2.00  1.00 -0.92\nage5*     8 42  1.55  0.50   2.00    1.56  0.00  1.00   2.00  1.00 -0.18\nbmi       9 42 27.55  4.26  28.54   27.91  4.68 17.09  33.01 15.93 -0.66\n       kurtosis   se\nId        -1.14 4.16\nAge       -0.44 0.33\nSex*        NaN 0.00\nHeight    -0.79 0.02\nWeight    -0.20 3.10\nSmoke*    -2.04 0.08\nami*      -1.19 0.07\nage5*     -2.01 0.08\nbmi       -0.45 0.66\n\n\nComo se puede observar, la salida no está para ser publicada.\nComo también habremos comentado en las clases de teoría, las variables categóricas ofrecen menos posibilidades descriptivas (contienen menos información) y su descripción univariada se va a reducir a dar las frecuencias absolutas y relativas.\nLa obtención de una tabla de contingencia es relativamente fácil.\n\ntable(iam$Sex,iam$Smoke)\n\n       \n        No Yes\n  Men   40  18\n  Women 20  22\n\n\nY la de las frecuencias relativas por (condicionadas a) fila o columna, también.\n\nt1<-table(iam$Sex,iam$Smoke)\nprop.table(t1,1) # 1 le indca que son los % sobre el total de fila, por eso suman 100%.\n\n       \n               No       Yes\n  Men   0.6896552 0.3103448\n  Women 0.4761905 0.5238095\n\n\nLos de la tabla anterior son las proporciones de fumadores en el grupo de mujeres (31%) y de hombres (52%).\nLos de la siguiente son la proporción de hombres dentro de cada nivel de la variable fumador (sí/no).\nEntre los no fumadores el 66.7% fueron hombres y el 33.3% fueron mujeres.\n\nprop.table(t1,2) # 2 le indca que son los % sobre el total de fila, por eso suman 100%.\n\n       \n               No       Yes\n  Men   0.6666667 0.4500000\n  Women 0.3333333 0.5500000\n\n\nExisten funciones para ver los márgenes.\n\naddmargins (table(iam$Sex,iam$Smoke))\n\n       \n         No Yes Sum\n  Men    40  18  58\n  Women  20  22  42\n  Sum    60  40 100\n\n\nIr variable a variable no es lo que necesitamos cuando queremos resumir muchas variables, por lo que algunos paquetes facilitan obtener esta información de varias variables a la vez.\n\ntableone::CreateCatTable(data=iam,vars=c('Smoke','ami','age5'),strata = 'Sex',test = F)\n\n                    Stratified by Sex\n                     Men        Women     \n  n                  58         42        \n  Smoke = Yes (%)    18 (31.0)  22 (52.4) \n  ami = Yes (%)      20 (34.5)  30 (71.4) \n  age5 = (65,75] (%) 30 (51.7)  23 (54.8) \n\n\nIncluso son capaces de distinguir el tipo de variable para utilizar el descriptor adecuado.\n\ntableone::CreateTableOne (data=iam[,-1],strata = 'Sex',test = F)\n\n                    Stratified by Sex\n                     Men           Women         \n  n                     58            42         \n  Age (mean (SD))    65.15 (2.07)  65.13 (2.14)  \n  Sex = Women (%)        0 ( 0.0)     42 (100.0) \n  Height (mean (SD))  1.67 (0.16)   1.70 (0.16)  \n  Weight (mean (SD)) 70.31 (12.45) 80.58 (20.06) \n  Smoke = Yes (%)       18 (31.0)     22 ( 52.4) \n  ami = Yes (%)         20 (34.5)     30 ( 71.4) \n  age5 = (65,75] (%)    30 (51.7)     23 ( 54.8) \n  bmi (mean (SD))    24.96 (1.10)  27.55 (4.26)  \n\n\nAlgunos incluso devuelven información gráfica.\n\nprint(summarytools::dfSummary(iam[,-1],\n                        plain.ascii  = FALSE,\n          style        = 'grid',\n          graph.magnif = 0.85,\n          varnumbers = FALSE,\n          valid.col    = FALSE,\n          # tmp.img.dir  = \"/tmp\"\n          ),method = 'render')\n\n\n\nData Frame Summary\niam\nDimensions: 100 x 8\n  Duplicates: 0\n\n\n  \n    \n      Variable\n      Stats / Values\n      Freqs (% of Valid)\n      Graph\n      Missing\n    \n  \n  \n    \n      Age\n[numeric]\n      Mean (sd) : 65.1 (2.1)min ≤ med ≤ max:59.5 ≤ 65.2 ≤ 70.7IQR (CV) : 3 (0)\n      100 distinct values\n      \n      0\n(0.0%)\n    \n    \n      Sex\n[factor]\n      1. Men2. Women\n      58(58.0%)42(42.0%)\n      \n      0\n(0.0%)\n    \n    \n      Height\n[numeric]\n      Mean (sd) : 1.7 (0.2)min ≤ med ≤ max:1.1 ≤ 1.7 ≤ 2IQR (CV) : 0.2 (0.1)\n      38 distinct values\n      \n      0\n(0.0%)\n    \n    \n      Weight\n[numeric]\n      Mean (sd) : 74.6 (16.8)min ≤ med ≤ max:30.3 ≤ 77.4 ≤ 121.9IQR (CV) : 17.8 (0.2)\n      76 distinct values\n      \n      0\n(0.0%)\n    \n    \n      Smoke\n[factor]\n      1. No2. Yes\n      60(60.0%)40(40.0%)\n      \n      0\n(0.0%)\n    \n    \n      ami\n[factor]\n      1. No2. Yes\n      50(50.0%)50(50.0%)\n      \n      0\n(0.0%)\n    \n    \n      age5\n[factor]\n      1. [55,65]2. (65,75]\n      47(47.0%)53(53.0%)\n      \n      0\n(0.0%)\n    \n    \n      bmi\n[numeric]\n      Mean (sd) : 26 (3.1)min ≤ med ≤ max:17.1 ≤ 25.4 ≤ 33IQR (CV) : 3.6 (0.1)\n      77 distinct values\n      \n      0\n(0.0%)\n    \n  \n\nGenerated by summarytools 1.1.4 (R version 4.4.1)2025-09-08\n\n\n\nEn cualquier caso siguen siendo tablas que no están listas para ser publicadas.\nSi dio tiempo, en la última clase deberíamos haber visto una tabla construida como “publication-ready tables”.\nAquí incluyo un ejemplo, con los datos utilizados en esta sesión.\n\n\n\n\n\n\n  \n    \n      Table 1. Descriptive statistics of the sample by Sex\n    \n    \n    \n      Characteristic\n      Men\nN = 581\n      Women\nN = 421\n    \n  \n  \n    Age\n65.28 (63.74, 66.54)\n65.19 (63.72, 66.78)\n    Height\n1.70 (1.57, 1.79)\n1.72 (1.58, 1.79)\n    Weight\n75 (61, 81)\n81 (73, 93)\n    Smoke\n18 (31%)\n22 (52%)\n    AMI\n20 (34%)\n30 (71%)\n    Age group\n\n\n        [55,65]\n28 (48%)\n19 (45%)\n        (65,75]\n30 (52%)\n23 (55%)\n    BMI\n24.68 (24.20, 25.79)\n28.54 (24.48, 31.30)\n  \n  \n  \n    \n      1 Median (Q1, Q3); n (%)\n    \n  \n\n\n\n\n\n6.1.1 Gráficos simples.\nIncluyo aquí algunos gráficos elaborados con las opciones gráficas en lo que he denominado base R. No serán los que utilizaremos para publicar, pero son perfectamente correctos.\n\n6.1.1.1 Gráficos. Variables categóricas.\n\n6.1.1.1.1 Gráficos de columnas.\nCuriosamente es uno de los gráficos más sencillos y sin embargo en base R su personalización es laboriosa, entre otras cosas porque necesita construir previamente una tabla.\n\nt2<-100*prop.table(table(iam$Smoke,iam$Sex),2)\np<-barplot(t2,beside=T,col=c('cadetblue','red'),\n        ylim=c(0,100),\n        ylab='%',\n        xlab='Sex')\ntext(x = c('uno','dos'))\n\nWarning in xy.coords(x, y, recycle = TRUE, setLab = FALSE): NAs introducidos\npor coerción\n\n\n\n\n\n\n\n\n6.1.1.2 Gráficos. Variables continuas.\nAlgo similar va a ocurrir con respecto a las posibilidades gráficas en la descripción univariada.\nDesarrollamos aquí los gráficos vistos durante las clases.\n\n6.1.1.2.1 Histograma\n\nhist(iam$Age) # las opciones ayudan a mejorar la presentación. \n\n\n\nhist(iam$Age,freq=F,col=\"blue\",xlab=\"Edad\") #prob=T es lo mismo que freq=F\nlines(density(iam$Age)) # para que dibuje la función de densidad. Necesita prob=T (*)\n\n\n\n\nSe puede sofisticar algo más.\nEsta representación fusiona los dos histogramas y juega con la transparencia para comparar su distribuciones.\n\nhist(iam$Age[iam$Sex==\"Men\"],freq=F,col=rgb(1,0,0,1/5),xlab='Age',main='Histogram of Age by Sex')\nhist(iam$Age[iam$Sex==\"Women\"],freq=F,col=rgb(0,0,1,1/5),add=T,xlab='Age')\n\n\n\n#Es necesario usar freq=T porque si saca las absolutas el grupo más grande destacará sobre el grupo más pequeño.\n\n\n\n6.1.1.2.2 Boxplot\n\n6.1.1.2.2.1 Una variable.\n\nboxplot(iam$Age)\n\n\n\nboxplot(iam$Age,col=\"red\")\ntext(1.25,median(iam$Age),round(median(iam$Age),2)) # función gráfica de bajo nivel.\n\n\n\n\n\n\n6.1.1.2.2.2 Por grupos de otra variable categórica.\nIncluimos algunas ociones de configuración.\nLas etiquetas salen porque las hemos deficido en el factor, de otra forma saldrían los valores (0,1)\n\nboxplot(formula=Age~Sex,data=iam,\n        col=c('orange','purple')\n        )\n\n\n\n\n\n\n\n6.1.1.2.3 Stem&Leaf\nLo incluyo por cuestiones históricas y porque realmente aporta información que el histograma no, pero es raro ya ver este gráfico.\n\nstem(iam$Age)\n\n\n  The decimal point is at the |\n\n  58 | 5\n  60 | 92579\n  62 | 1235567788890114557799\n  64 | 0112334455577788890112233344445555799\n  66 | 002334456788802222233455\n  68 | 1122344662\n  70 | 7\n\n\n\n\n6.1.1.2.4 Gráfico Q-Q.\nGráfica cuantil-cuantil frente a distribución normal.\nEste gráfico es muy útil y sirve para analizar visualmente si una distribución empírica (nuestros datos observados) sigue razonablemente bien una distribución normal2. Cuando la sigue, los puntos se distribuyen cerca de la línea.\nPara ello enfrentan los datos observados frente a los cuantiles que ocuparían en una distribución, en este caso normal.\nLas coordenadas en cada eje para cada punto se construyen de la siguiente manera3.\nEn el eje de ordenadas (eje y) representa la posición que ocupan los valores observados expresada en cuantiles desde el centro de la distribución empírica. En el eje de abscisas (eje x) se representa la posición que ocuparían dichos valores en una distribución teórica normal perfecta con la misma media y desviación típica que la distribución empírica.\nSi la distancia (expresada en cuantiles) a la que está un punto observado en la distribución empírica coincidiese perfectamente con la distancia (expresada en cuantiles) a la que estaría ese mismo punto en una distribución normal perfecta con la misma media y desviación típica que la de la distribución empírica, todos los puntos se colocarían en la diagonal diagonal. Si se apartan, es que los puntos no están donde se les espera, informando de asimetrías en las colas, distribuciones bimodales, existencia de valores atípicos…\nHace falta cierta experiencia para interpretar los detalles finos, pero es un gráfico bastante intuitivo para identificar problemas con la normalidad de la variable incluso al ojo menos experimentado.\n\nqqnorm #(Gráfico cuantil-cuantil de distribución de variable problema frente a distribución normal con misma media y desviación típica que la de la variable problema).\n\nfunction (y, ...) \nUseMethod(\"qqnorm\")\n<bytecode: 0x00000280c9c0ac00>\n<environment: namespace:stats>\n\nqqnorm(iam$Age)\nqqline(iam$Age)\n\n\n\n\n\n\n\n\n6.1.2 Gráfico de dispersión o scatter plot.\nEn este representamos la relación bivariada entre dos variables cuantitativas, preferentemente continuas.\n\nplot(iam$Age,iam$bmi,main='Scatter plot BMI by Age',\n     xlab='Age [yrs.]',\n     ylab=expression(paste('Body Mass Index [',Kg/m^2,']')) #Es posible insertar fórmulas, aunque no siempre es fácil.\n)\n\n\n\n\nSi tuviésemos que ir una a una, supondría mucho trabajo. Existen funciones que nos pueden devolver múltiples tipos de relación simultáneamente.\n\npairs(iam[,c('Age','Height','Weight','bmi')])\n\n\n\n\nComo pasaba con las tablas, estos gráficos no son aún ‘Publication-ready Graphs’. Dado que este tipo de gráficos no son necesarios para superar el bloque, si da tiempo hablaremos de cómo crearlos en la última sesión."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Broman, Karl W., and Kara H. Woo. 2018. “Data Organization in\nSpreadsheets.” The American Statistician 72 (1): 2–10.\nhttps://doi.org/10.1080/00031305.2017.1375989.\n\n\nGandrud, Christopher. 2020. Reproducible Research with R and\nRStudio. Boca Raton, FL.\n\n\nGrolemund, Garrett, and Hadley Wickham. 2017. R for Data\nScience. 1st edition. Sebastopol, CA: O’Reilly Media. http://r4ds.had.co.nz/.\n\n\nKelion, Leo. 2020. “Excel: Why Using Microsoft’s Tool Caused\nCovid-19 Results to Be Lost.” BBC News, October. https://www.bbc.com/news/technology-54423988.\n\n\nRuiz, Armand. 2017. “The 80/20 Data Science Dilemma.”\nInfoWorld. https://www.infoworld.com/article/3228245/the-80-20-data-science-dilemma.html.\n\n\nThe Carpentries. n.d. “Formatting Problems Data Organization in\nSpreadsheets for Ecologists.” Accessed December 1, 2022. https://datacarpentry.org/spreadsheet-ecology-lesson/02-common-mistakes.html.\n\n\nWickham, Hadley. 2014. “Tidy Data.” Journal of\nStatistical Software 59 (September): 1–23. https://doi.org/10.18637/jss.v059.i10."
  }
]