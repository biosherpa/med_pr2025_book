[
  {
    "objectID": "Practicas_2024_25/Practica_1/Practica_1_pdf.html#section",
    "href": "Practicas_2024_25/Practica_1/Practica_1_pdf.html#section",
    "title": "2  Práctica 1. Introducción a R y RStudio",
    "section": "2.1 ",
    "text": "2.1"
  },
  {
    "objectID": "Practicas_2024_25/Practica_1/Practica_1_pdf.html#qué-es-r-y-cómo-funciona-r",
    "href": "Practicas_2024_25/Practica_1/Practica_1_pdf.html#qué-es-r-y-cómo-funciona-r",
    "title": "2  Práctica 1. Introducción a R y RStudio",
    "section": "2.2 1. ¿Qué es R y cómo funciona R?",
    "text": "2.2 1. ¿Qué es R y cómo funciona R?\nR es un lenguaje de programación y un entorno de software diseñado especialmente para el análisis estadístico y la manipulación de datos. A diferencia de otros lenguajes de programación que necesitan ser compilados en un archivo ejecutable antes de su uso, R es un lenguaje interpretado. Esto significa que puedes escribir y ejecutar comandos de forma interactiva, lo que te permite ver los resultados de inmediato sin necesidad de un proceso de compilación previo. Esta característica hace que R sea especialmente útil para tareas exploratorias y análisis rápidos.\n\n2.2.1 1.1 Un poco de historia\nLa historia de R comienza en 1992, cuando Robert Gentleman y Ross Ihaka, del Departamento de Estadística de la Universidad de Auckland en Nueva Zelanda, empezaron a desarrollar el lenguaje. Sin embargo, si se rastrea más atrás, se descubre que R tiene sus raíces en el lenguaje S, desarrollado por John Chambers y su equipo en los Laboratorios Bell (ahora Alcatel-Lucent) en Nueva Jersey desde finales de los años 70. El lenguaje S fue diseñado para el análisis de datos y sentó las bases para muchas herramientas estadísticas posteriores.\nR se creó combinando las fortalezas de dos lenguajes existentes: S y Scheme. Según los propios diseñadores, “el lenguaje resultante es muy similar en apariencia a S, pero en el uso de fondo y la semántica, es derivado de Scheme”. El nombre “R” fue elegido en parte para reconocer la influencia de S y en parte para destacar sus propias innovaciones.\nLa primera versión de R, la 0.16, fue una versión alfa desarrollada por Ihaka y Gentleman y presentó muchas de las características descritas en el “White Book”. En 1997, se lanzó la versión 0.49, la versión más antigua cuyo código se conserva y que aún compila en algunas plataformas UNIX. Este año también marcó el inicio del CRAN (Comprehensive R Archive Network) con tres espejos y doce paquetes. En diciembre de 1997, R se convirtió en parte del Proyecto GNU, una iniciativa para desarrollar software libre. Como parte de esta integración, el código fuente de R empezó a gestionarse y controlarse mediante CVS (Concurrent Versions System), una herramienta para el manejo de versiones de software. Esto permitió un control más organizado y colaborativo sobre el desarrollo y las actualizaciones del código de R.\nA lo largo de los años, R ha evolucionado significativamente. La versión 1.0.0, lanzada el 29 de febrero de 2000, fue la primera versión considerada suficientemente estable para su uso en producción. En versiones posteriores, se introdujeron importantes mejoras como los métodos S4 en la versión 1.4.0, el soporte para UTF-8 en la versión 2.1.0, y el “lazy loading” para una carga rápida de datos en la versión 2.0.0. En 2004, Insightful Corporation adquirió S y agregó un entorno gráfico, y en 2008, TIBCO compró Insightful.\nLa evolución de R continuó con mejoras constantes en el rendimiento y la funcionalidad, incluyendo soporte para sistemas Windows de 64 bits en la versión 2.11.0 y mejoras en la internacionalización y la velocidad de serialización en versiones posteriores. La versión 3.0.0, lanzada en abril de 2013, introdujo mejoras en la interfaz gráfica de usuario, funciones gráficas, gestión de memoria y rendimiento. La versión 3.4.0, lanzada en abril de 2017, habilitó el compilador JIT (“Just In Time”) en el nivel 3 de forma predeterminada, marcando un hito importante en la optimización del rendimiento.\nHoy en día, R sigue siendo desarrollado y mantenido por el R Development Core Team, y es una herramienta esencial en el análisis estadístico y la visualización de datos, con una comunidad activa que contribuye a su constante evolución. Para conocer más sobre los autores y desarrolladores actuales de R, se puede consultar la lista de contribuyentes usando el comando contributors(); en el entorno de R..\nPero además de sus creadores existe una “comunidad” alrededor de R que juega un papel crucial en el éxito y la expansión del lenguaje de programación R. Su importancia radica no solo en la cantidad de usuarios que confían en R para sus análisis estadísticos y científicos, sino también en la vibrante red de colaboración y soporte que impulsa continuamente la evolución del lenguaje. La participación activa de sus miembros ha sido clave para el desarrollo de una vasta cantidad de recursos, herramientas y conocimientos compartidos que enriquecen el ecosistema R.\nLa Comunidad R\nLa comunidad global de R no solo está formada por usuarios, sino también por contribuyentes que desarrollan paquetes para la biblioteca CRAN y brindan apoyo en foros y plataformas. Es conocida por su dinamismo y compromiso, donde sus miembros gestionan foros, escriben blogs especializados y responden preguntas en Stack Overflow, creando una sólida red de soporte.\nAdemás, la comunidad organiza conferencias sobre R en todo el mundo, ofreciendo oportunidades para aprender, compartir conocimientos y conectar con otros profesionales y entusiastas.\nSi estás comenzando con R, seguramente encontrarás un paquete que se ajuste a tus necesidades. La comunidad ha desarrollado miles de herramientas que amplían las capacidades de R, con CRAN albergando casi 20.000 paquetes.\n\n\n2.2.2 1.2 Cómo funciona R\nR trabaja con objetos (variables, datos, funciones, resultados) que se almacenan en la memoria activa y se manipulan mediante operadores y funciones. Los resultados también son objetos que pueden analizarse. Los archivos solo se usan para entrada y salida de datos, mientras que las funciones se organizan en paquetes, con el paquete base como núcleo para tareas clave de manipulación de datos y análisis estadístico. Los operadores en R son intuitivos, y las funciones, que también son objetos, permiten realizar análisis complejos. La sintaxis accesible y su estructura orientada a objetos hacen de R una herramienta eficaz para el análisis de datos.\nA diferencia de los programas tradicionales que muestran inmediatamente los resultados, R almacena los resultados como objetos, lo que permite al usuario trabajar con ellos más tarde. Por ejemplo, si se está analizando una gran base de datos y se construyen una decena de modelos explicativos de los cuáles solo se quiere elegir uno, R guarda el objeto que contiene toda la información de cada modelo. En lugar de mostrar todos los detalles de cada uno de ellos inmediatamente, se puede extraer solo la bondad de ajuste o los coeficientes de cada modelo, sin tener que lidiar con una salida masiva de información. Esto hace que R sea más flexible y eficiente en el manejo de datos complejos.\n\nEsquema del funcionamiento de R (tomado de Paradis, E. (2005).  R for Beginners. Institut des Sciences de l’Evolution. Université Montpellier II.)\nOtra de las ventajas de R es su sintaxis sencilla, que permite a los usuarios realizar operaciones y análisis complejos de manera intuitiva. A diferencia de otros lenguajes de programación que requieren estructuras más elaboradas, R utiliza comandos directos que facilitan el trabajo desde el principio, lo que permite a los usuarios centrarse en el análisis sin preocuparse demasiado por la complejidad técnica.\nAdemás, R es consistente en el uso de las funciones, todas las funciones en R deben incluir paréntesis, lo que crea una estructura clara y predecible. Esta característica asegura que los usuarios sepan exactamente cómo interactuar con cada función, independientemente de si reciben o no argumentos. Si se omiten los paréntesis, en lugar de ejecutar la función, R muestra su definición interna, lo que permite a los usuarios ver y entender cómo está diseñada.\nEste enfoque estructurado y accesible de R fomenta tanto el aprendizaje rápido como la exploración más profunda del código. Los usuarios pueden comenzar realizando operaciones básicas, pero también tienen la libertad de explorar cómo se construyen las funciones y modificarlas si es necesario, lo que convierte a R en una herramienta altamente flexible para el análisis de datos."
  },
  {
    "objectID": "Practicas_2024_25/Practica_1/Practica_1_pdf.html#comenzando-a-trabajar-con-r",
    "href": "Practicas_2024_25/Practica_1/Practica_1_pdf.html#comenzando-a-trabajar-con-r",
    "title": "2  Práctica 1. Introducción a R y RStudio",
    "section": "2.3 2. Comenzando a trabajar con R",
    "text": "2.3 2. Comenzando a trabajar con R\n\n2.3.1 2.1 Instalación de R\nPara instalar R vamos a la página web de R project: http://www.r-project.org.\n\nDespués seleccionamos el “espejo” más conveniente, en nuestro país una opción adecuada está en la Red Iris The Comprehensive R Archive Network (rediris.es) https://cran.rediris.es/. Allí nos descargaremos el formato conveniente en función del sistema operativo.\nEn el entorno de la URJC lo tenemos operativo en MyApps https://myapps.urjc.es/myapps/Apps\nAl instalar R, el paquete base se incluye automáticamente. Este paquete proporciona herramientas esenciales para manipular datos, realizar cálculos estadísticos y crear gráficos. No es necesario instalarlo por separado, ya que está disponible desde el inicio para que puedas empezar a trabajar con R de inmediato.\n\n\n2.3.2 2.2 RStudio: una interfaz para usar R\nAunque puedes ejecutar R directamente desde la línea de comandos, RStudio es una interfaz gráfica que facilita el uso de R, especialmente para principiantes.\nRStudio se descarga desde su página oficial https://www.rstudio.com/\nPero también puedes encontrarla en MyApps\nEsta es la apariencia de RStudio\n\nEn RStudio, la consola se encuentra por defecto en el panel inferior izquierdo, en la pestaña etiquetada como Console. Aquí es donde interactuamos directamente con R. Debajo de esta pestaña, verás un texto introductorio seguido del símbolo “>”, que indica que R está listo para recibir instrucciones. En esta consola puedes escribir comandos o código, y al pulsar Enter, R ejecutará el comando y mostrará el resultado inmediatamente en la misma consola. Es el lugar principal para ejecutar scripts de manera interactiva y ver resultados en tiempo real.\nEscribe esta operación en la consola y mira el resultado\n\n3+2\n\n[1] 5\n\n\nTambién pueden introducirse órdenes diversas en la consola en líneas sucesivas o separadas por el símbolo ;\n\n3+2 \n\n[1] 5\n\n2*(4-1)^2 \n\n[1] 18\n\nlog10 (100) \n\n[1] 2\n\nsqrt(36)\n\n[1] 6\n\n3+2 ; 2*(4-1)^2 ; log10 (100) ;sqrt(36)\n\n[1] 5\n\n\n[1] 18\n\n\n[1] 2\n\n\n[1] 6\n\n\nEn RStudio, el panel de script se encuentra en la parte superior izquierda, permitiendo escribir y ejecutar instrucciones línea por línea o en bloque, igual que en la Consola. Para ejecutar el código, puedes optar por varias alternativas: hacer clic en el botón Run en la parte derecha del panel de script, o puedes usar el atajo Ctrl+Enter.\nLos contenidos del panel script pueden guardarse usando File > Save as.. y seleccionar la ruta deseada, o haciendo clic en el botón Guardar en la cinta de opciones del script.\nEl panel de Entorno en RStudio está dividido en dos pestañas principales: Environment y History (otra denominada Connection no la explicaremos de momento)\nEn la pestaña Environment, se muestran todos los objetos (como variables, data frames, y otros elementos) que has creado durante tu sesión de trabajo. Aquí también puedes gestionar tu sesión de trabajo mediante opciones como cargar y guardar el estado actual, importar datos y limpiar los objetos de la sesión. Estas funciones son accesibles a través de la cinta de opciones situada en esta pestaña, facilitando la administración de tus datos y objetos.\nLa pestaña History registra todas las instrucciones que has ejecutado. Además de mostrar un historial completo de los comandos utilizados, te permite gestionar este historial de manera eficiente. Puedes cargar y guardar el historial de comandos, seleccionar uno o varios comandos y enviarlos a la consola o al script para su re-ejecución. También puedes limpiar el historial cuando ya no lo necesites. Esta pestaña es útil para revisar y reutilizar comandos anteriores, lo que facilita el trabajo continuo y la replicación de análisis.\nEl panel habitualmente situado en el cuadrante inferior derecho contiene, a su vez, varias pestañas.\nEntre las pestañas destacadas se encuentran:\n\nFiles: Actúa como un explorador de archivos, permitiendo la navegación y gestión de los archivos en el sistema.\nPlots: Muestra los gráficos generados durante la sesión. En esta pestaña, se pueden utilizar opciones como Zoom para ampliar los gráficos en una ventana separada, y Export para guardar los gráficos en formatos de imagen, PDF, o copiarlos al portapapeles.\nPackages: Ofrece un listado de los paquetes instalados en R y aquellos que están cargados en la sesión actual. Desde esta pestaña, se pueden instalar nuevos paquetes, así como actualizar los ya existentes.\nHelp: Proporciona asistencia sobre funciones específicas, facilitando la consulta de documentación y ayuda relacionada con el uso de diversas funciones en R.\n\n\n\n2.3.3 2.3 Establecer el directorio de trabajo\nAntes de empezar a trabajar en R, debes fijar el directorio donde se guardarán tus archivos. Hay dos maneras de hacerlo:\n\nFijar el directorio manualmente: Usa la función setwd(\"C:/ruta del directorio de trabajo\") para establecer la ruta de trabajo. Para verificar la ruta actual, usa getwd(), y para listar los archivos en el directorio, utiliza dir().\nCrear un proyecto de R: Selecciona File > New Project… para vincular todos los archivos al proyecto. Puedes crear un nuevo directorio con un proyecto vacío o elegir una carpeta existente. Al crear el proyecto, se genera un archivo .Rproj, y todos los archivos asociados se guardarán en la carpeta del proyecto. Para abrir un proyecto, haz doble clic en el archivo .Rproj o selecciona File > Open Project… en RStudio.\n\nLos proyectos facilitan la organización, ya que todos los archivos creados se guardan automáticamente en la carpeta del proyecto.\nEs importante como se debe indicar la ruta de cualquier archivo en R. En la navegación de archivos y rutas en sistemas operativos, el uso de barras invertidas (\\) y barras normales (/) tiene diferentes significados según el entorno.\nCuando se trabaja en R y RStudio, se debe tener en cuenta que R utiliza barras normales (/) en las rutas de archivos . Sin embargo, si estás escribiendo rutas en Windows y usas barras invertidas (\\), (como hace Windows habitualmente) recuerda que en R se debe duplicar cada barra invertida para que se interprete correctamente, es decir, podras escibir\nC:/Users/Usuario/Documents/Archivo.txt. o\nC:\\\\Users\\\\Usuario\\\\Documents\\\\Archivo.txt.\n\n\n2.3.4 2.4 Instalación y uso de paquetes\nUn paquete es un conjunto de funciones, datos y documentación que están organizados para realizar tareas específicas. R viene con algunos paquetes preinstalados, pero puedes descargar e instalar muchos más desde repositorios en línea o desde archivos locales en tu computadora. Para la instalación desde repositorios necesitarás una conexión a Internet, pero puedes hacerlo desde directorios locales si ya tienes el archivo del paquete en tu computadora.\nPaquetes base\nLos paquetes “base” ya vienen preinstalados con R y se pueden cargar directamente usando la función library(). Por ejemplo:\n\nlibrary(\"stats\")\n\nEste comando carga el paquete stats, el cual es parte de la instalación base y proporciona funciones estadísticas comunes.\nOtros paquetes\nPara utilizar paquetes adicionales disponibles en CRAN, deben realizarse dos pasos: la instalación y la carga.\nLa instalación se realiza mediante la función install.packages(), y la carga posterior se realiza con library(). Por ejemplo, para instalar y cargar el paquete ggplot2, se haría lo siguiente:\n\ninstall.packages (\"ggplot2\")   \nlibrary(\"ggplot2\")           \n\nEs importante entender que las funciones de un paquete no están disponibles hasta que el paquete ha sido cargado explícitamente con library(). Esto es para mejorar la eficiencia del sistema y evitar conflictos de espacio de nombres, es decir, evitar que dos funciones con el mismo nombre de diferentes paquetes interfieran entre sí. Si alguna vez una función no se ejecuta, y funcionó en el pasado, es recomendable verificar si el paquete correspondiente ha sido cargado.\nPara saber que un paquete está instalado se puede usar la función find()\n\nfind.package(\"ggplot2\")\n\n[1] \"C:/Users/Usuario/Documents/GitHub/med_pr2025_book/renv/library/windows/R-4.4/x86_64-w64-mingw32/ggplot2\"\n\n\nFinalmente, si un paquete ya no es necesario, puede ser removido con remove.packages(), liberando espacio y manteniendo el entorno de trabajo más organizado.\n\nremove.packages(\"ggplot2\")\n\nEstructura de los paquetes en R\nUna vez instalado, un paquete se guarda en una carpeta específica dentro del directorio R HOME/library, que es el directorio donde R está instalado. Cada paquete contiene sus funciones organizadas en subdirectorios. Por ejemplo, el paquete base (parte del núcleo de R) está ubicado en R HOME/library/base/R/base, y contiene un archivo en formato ASCII que incluye todas las funciones del paquete.\n\n\n2.3.5 2.5 La ayuda en R\nExisten diversas formas de buscar ayuda en R\n\nhelp(función) o ?función: Ayuda para una función.\n\n\nhelp(mean)\n?mean\n\n\nargs(función): Argumentos de una función.\n\n\nargs(mean)\n\nfunction (x, ...) \nNULL\n\n\n\nhelp(package = \"paquete\"): Documentación del paquete.\n\n\nhelp(package = \"ggplot2\")\n\nMuestra la documentación del paquete ggplot2.\n\nvignette(package=):\n\n\nvignette(package = \"ggplot2\")\n\nMuestra vignettes de ggplot2\nLas vignettes en R son documentos extensos que proporcionan una visión detallada y práctica sobre cómo usar un paquete, sus funciones y sus características. A menudo incluyen ejemplos, tutoriales, y descripciones de cómo aplicar el paquete para resolver problemas específicos. Las vignettes son una forma útil de aprender sobre un paquete y cómo aprovecharlo al máximo.\n\nhelp.search(\"término\") o ??\"término\":\n\n\nhelp.search(\"plot\") \n??plot\n\nBusca en la ayuda de R.\nExisten otras funciones de ayuda en R\n\nsearch(): Muestra los objetos y paquetes actualmente cargados en la sesión de R.\ndata(): Lista los conjuntos de datos disponibles en los paquetes cargados.\navailable.packages(): Muestra todos los paquetes disponibles en el repositorio CRAN o el repositorio establecido con setRepositories().\ninstalled.packages(): Lista los paquetes instalados en todas las bibliotecas especificadas en .libPaths(), proporcionando más detalles que library().\nhelp(package=\"ggplot2\"): Proporciona ayuda sobre el paquete ggplot2, mostrando la documentación general del paquete.\nhelp(ggplot, package=\"ggplot2\"): Ofrece ayuda sobre la función ggplot dentro del paquete ggplot2, útil cuando varias funciones tienen el mismo nombre en diferentes paquetes.\nlibrary(help=\"dplyr\"): Muestra la documentación del paquete dplyr en un formato diferente.\npackage?dplyr: Muestra una descripción del paquete dplyr, aunque no todos los paquetes tienen documentación accesible de esta manera.\nls(\"package:tidyr\"): Lista las funciones y objetos disponibles en el paquete tidyr, que debe estar cargado en la sesión.\n\nRecuerda que en RStudio en el panel de la parte inferior derecha hay también una pestaña de ayuda con un buscador de términos"
  },
  {
    "objectID": "Practicas_2024_25/Practica_1/Practica_1_pdf.html#operando-con-r.",
    "href": "Practicas_2024_25/Practica_1/Practica_1_pdf.html#operando-con-r.",
    "title": "2  Práctica 1. Introducción a R y RStudio",
    "section": "2.4 3. Operando con R.",
    "text": "2.4 3. Operando con R.\nEn R, el lenguaje es case-sensitive, lo que significa que distingue entre mayúsculas y minúsculas, haciendo que Variable, variable, y VARIABLE se consideren nombres distintos. Los nombres de objetos no pueden contener espacios; en su lugar, se deben usar guiones bajos (_) o la notación de camello (camelCase) para separar palabras (esto último lo usamos menos). Además, los nombres deben comenzar con una letra o un punto seguido de una letra, y pueden incluir letras, números, y puntos o guiones bajos después del primer carácter. Nombres que comienzan con números o que contienen espacios o caracteres especiales generarán errores.\nLos caracteres reservados como =, $, &, y *, así como caracteres especiales como ä, ü, í, no están permitidos en los nombres de objetos, ya que pueden causar errores o comportamientos inesperados.\n\n2.4.1 3.1 Las líneas de código en R\nEn R, como ya señalamos, los comandos se pueden separar por punto y coma (;) o por saltos de línea. Esto permite flexibilidad en cómo se estructuran y escriben los comandos en el código. Por ejemplo:\n\nx <- 10; y <- 20; z <- x + y\n\nCrea los mismos objetos que\n\nx <- 10\ny <- 20\nz <- x + y\n\nAdemás, R permite que el código se escriba en varias líneas y se agrupen bloques de código usando llaves ({}). Esto es especialmente útil para definir funciones, estructuras de control , o simplemente para organizar el código en secciones claras. Por ejemplo:\n\n{\n  x <- 5\n  y <- x * 2\n  print(y)\n}\n\n[1] 10\n\n\nLos comentarios en R se introducen con el símbolo #. Todo lo que sigue a este símbolo en una línea se considera un comentario y no se ejecuta. Los comentarios no afectan la ejecución del código, pero hacen que sea más fácil entender y mantener el código en el futuro. Por ejemplo:\n\n# Este es un comentario\nx <- 10  # Asignamos 10 a x\ny <- 20  # Asignamos 20 a y\n\n# Calculamos la suma\nz <- x + y\nz\n\n[1] 30\n\n\n\n\n2.4.2 3.2 Creación de objetos con R\nEn R, los objetos se crean y asignan utilizando el operador <-, que es la forma más común de asignar valores a variables. Los objetos pueden tener diferentes tipos de datos, como numérico, carácter, lógico o complejo, y cada uno tiene atributos que definen su naturaleza y tamaño. Por ejemplo, puedes crear un objeto numérico asignando un valor entero o decimal a una variable, como x <- 1 o y <- 3.14.\n\nx<-1 \nx \n\n[1] 1\n\ny<-3.14\ny\n\n[1] 3.14\n\n\nDel mismo modo, puedes crear un objeto carácter asignando una cadena de texto, como nombre <- \"Juan\".\n\nnombre <- \"Juan\" \nnombre\n\n[1] \"Juan\"\n\n\nTambién existen objetos con valores lógicos . En R, un objeto lógico es una variable que puede tener uno de dos valores posibles: TRUE (verdadero) o FALSE (falso). Los valores lógicos se utilizan para realizar operaciones de comparación, control de flujo en el código, y para representar estados binarios o condiciones en tus análisis.\n\nnumeros <- 1:5  # Crear un vector lógico que indica si los números son mayores que 3 \nmayor_que_tres <- numeros > 3  # Mostrar el vector lógico \nprint(mayor_que_tres)\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n\nCada objeto tiene dos atributos principales: tipo de dato y longitud. El tipo de dato indica la clase básica del objeto, mientras que la longitud se refiere al número de elementos que contiene.\n\nx <- (1:5) \nA <- \"Australopitecus\"  \n# Ver el tipo y longitud de los objetos \nmode(x)       \n\n[1] \"numeric\"\n\nlength(x) \n\n[1] 5\n\nmode(A)       \n\n[1] \"character\"\n\nlength(A)\n\n[1] 1\n\n\nR también maneja valores especiales como NA (not Available) para datos faltantes, Inf y -Inf para infinito positivo y negativo, y NaN (not a number) para resultados no válidos.\n\nc<-c(1,2,NA,4,5) \nc \n\n[1]  1  2 NA  4  5\n\n1/0 \n\n[1] Inf\n\n-1/0\n\n[1] -Inf\n\n0/0\n\n[1] NaN\n\n\nEn la próxima práctica se explicarán con más detalle los tipos de objetos en R.\nPara listar los objetos en el entorno de trabajo en R, puedes utilizar la función ls(), que proporciona una lista de todos los objetos actualmente disponibles. También puedes usar objects(), que es funcionalmente equivalente a ls(), o ls.str(), que ofrece una vista más detallada de los objetos junto con información sobre sus estructuras.\n\nls()\n\n[1] \"A\"              \"c\"              \"mayor_que_tres\" \"nombre\"        \n[5] \"numeros\"        \"x\"              \"y\"              \"z\"             \n\nobjects ()\n\n[1] \"A\"              \"c\"              \"mayor_que_tres\" \"nombre\"        \n[5] \"numeros\"        \"x\"              \"y\"              \"z\"             \n\nls.str()\n\nA :  chr \"Australopitecus\"\nc :  num [1:5] 1 2 NA 4 5\nmayor_que_tres :  logi [1:5] FALSE FALSE FALSE TRUE TRUE\nnombre :  chr \"Juan\"\nnumeros :  int [1:5] 1 2 3 4 5\nx :  int [1:5] 1 2 3 4 5\ny :  num 3.14\nz :  num 30\n\n\nFinalmente los objetos se pueden borrar con las funciones rm(), que permite eliminar uno o varios objetos del entorno de trabajo. Si deseas limpiar el entorno completamente, puedes usar rm(list = ls()) para borrar todos los objetos a la vez\n\nrm (x)\nrm (y,A)\nrm (list= ls())\n\n\n\n2.4.3 3.3 Las funciones en R\nEn R, las funciones son bloques de código reutilizables diseñados para realizar tareas específicas y pueden ser una herramienta poderosa en el análisis de datos. Cada función en R tiene una estructura compuesta por tres partes principales: el nombre de la función, los argumentos y las opciones.\nEl nombre de la función es el identificador que se utiliza para llamar a la función, y debe ser único y descriptivo para facilitar su comprensión y uso.\nLos argumentos son los valores que se pasan a la función para que realice su tarea, y pueden ser obligatorios o opcionales dependiendo de cómo esté diseñada la función.\nLas opciones son parámetros adicionales que permiten ajustar el comportamiento de la función, ofreciendo flexibilidad para personalizar su funcionamiento.\nPor ejemplo, en la función sum(), que se utiliza para calcular la suma de valores, el nombre de la función es sum, el argumento principal es ..., que representa los números a sumar, y la opción na.rm permite decidir si se deben ignorar los valores faltantes (NA).\n\nx1 <- c(1:10, NA, 12:20)\nresult1 <- sum(x1, na.rm = TRUE)\nresult1\n\n[1] 199\n\nx2 <- c(1:20)\nresult2 <- sum(x2, na.rm = TRUE)\nresult2\n\n[1] 210\n\n\nEn R, las funciones son una herramienta fundamental para estructurar el código de manera clara y eficiente. Al permitir que las tareas complejas se dividan en bloques más manejables, las funciones fomentan la modularidad, lo que facilita la reutilización del código y reduce la duplicación. Esto no solo mejora la legibilidad y el mantenimiento del código, sino que también optimiza el uso de recursos tanto del programador como del sistema. Además, el uso de argumentos y opciones dentro de las funciones brinda flexibilidad, permitiendo personalizar su comportamiento según las necesidades del análisis, lo que las convierte en un componente clave para escribir código adaptable y robusto."
  },
  {
    "objectID": "Practicas_2024_25/Practica_1/Practica_1_pdf.html#guardando-el-trabajo-realizado",
    "href": "Practicas_2024_25/Practica_1/Practica_1_pdf.html#guardando-el-trabajo-realizado",
    "title": "2  Práctica 1. Introducción a R y RStudio",
    "section": "2.5 4. Guardando el trabajo realizado",
    "text": "2.5 4. Guardando el trabajo realizado\nEn RStudio, existen varias formas de guardar tu trabajo dependiendo de lo que deseas conservar (scripts, resultados, gráficos, etc.). Aquí te explico las principales opciones:\n1. Guardar scripts o archivos de código R\nEl código que escribes en el editor de scripts de RStudio (los archivos con extensión .R) se puede guardar fácilmente como un archivo de texto. Basta con ir al menú File > Save o usar el atajo de teclado Ctrl + S (Windows)\n2. Guardar el entorno de trabajo (Workspace)\nEl entorno de trabajo incluye todos los objetos (variables, funciones, data frames, etc.) que has creado durante una sesión de R. Para guardar el entorno de trabajo ve a Session > Save Workspace As… y guarda el archivo con la extensión .RData. Esto permitirá que, al abrir el archivo más tarde, recuperes todos los objetos y variables tal como estaban al guardarlo. También puedes guardar manualmente usando el comando save.image(), que guarda el entorno actual en un archivo .RData:\n\nsave.image(file = \"mi_trabajo.RData\") \n\nMás tarde puede recuperarse mediante el uso de la función load()\n\nload(\"mi_trabajo.RData\") \n\n3. Guardar un proyecto de RStudio\nLos proyectos en RStudio ayudan a organizar mejor el trabajo, creando un entorno aislado con sus propios scripts, datos, y configuraciones. Se pueden guardar en la pestaña Save Project As… y guarda el proyecto con la extensión .Rproj. Esto permite cargar todo el entorno de trabajo, configuración, y scripts asociados con el proyecto en el futuro.\n4. Guardar gráficos\nSi has generado gráficos y deseas guardarlos, puedes hacerlo en varios formatos como PNG, PDF, JPEG, etc. Para guardar un gráfico desde la interfaz gráfica ve a la ventana de gráficos, haz clic en Export y selecciona Save as Image o Save as PDF. Puedes elegir el formato y la resolución. También puedes guardar un gráfico desde el código, utilizando funciones como png(), pdf(), o jpeg() antes de generar el gráfico.\n\npng(\"mi_grafico.png\")\nplot(x, y)  # Generar gráfico suponiendo que tenemos vectores x e y\ndev.off()  # Cerrar el dispositivo gráfico\n\n5. Guardar datos\nSi has trabajado con datos (por ejemplo un dataframe, ya ceremos más adelante) y deseas guardarlos en archivos externos (como CSV, Excel, etc.), puedes hacerlo utilizando funciones específicas para escribir archivos. En algunos casos hay que cargar previamente alguna librería, por ejemplo para guardar un excel\n\nwrite.csv(mis_datos, \"mis_datos.csv\") \n\n#Para un formato excel\nlibrary(writexl) \nwrite_xlsx(mis_datos, \"mis_datos.xlsx\")"
  },
  {
    "objectID": "Practicas_2024_25/Práctica_2/Práctica_2.1_pdf.html#tipos-de-objetos-en-r.",
    "href": "Practicas_2024_25/Práctica_2/Práctica_2.1_pdf.html#tipos-de-objetos-en-r.",
    "title": "3  Práctica 2. Introducción y manipulación de datos en R (1)",
    "section": "3.1 1.Tipos de objetos en R.",
    "text": "3.1 1.Tipos de objetos en R.\nR es capaz de gestionar diversos tipos de datos, que se organizan en distintas estructuras de datos. A continuación se presenta una tabla que describe los tipos de datos básicos en R:\n\n\n\n\n\n\n\n\nTipo de dato\nDescripción\nEjemplo\n\n\n\n\nNumeric\nNúmeros decimales\nnumero <- 1.0\n\n\nInteger\nNúmeros enteros\nint <- 1\n\n\nCharacter\nCadenas de texto\nstr <- \"texto\"\n\n\nComplex\nNúmeros complejos\ncomp <- 3+2i\n\n\nLogical\nValores de verdad: TRUE o FALSE, a menudo generados como resultado de operaciones lógicas.\na <- 1; b <- 2; a < b\n\n\nFactor\nLos factores son un tipo de variable, no de dato, las variables categóricas. Los vectores de caracteres suelen convertirse en factores para aprovechar las funciones que manejan datos categóricos, como en el análisis de regresión.\nUsando as.factor().\n\n\n\nLas estructuras de datos son objetos que contienen datos y organizados de diferentes maneras. Las estructuras vienen definidas por su número de dimensiones y por la homogeneidad o no de sus datos.\nLa siguiente tabla muestra las principales estructuras de datos que maneja R.\n\n\n\n\n\n\n\n\n\n\nObjeto\nModos\nDescripción\n¿Múltiples Modos ?\nDimensiones\n\n\n\n\nVector\nNumérico, Carácter, Complejo, Lógico\nSecuencia de elementos del mismo tipo (numérico, carácter, complejo, lógico).\nNo\n1D\n\n\nArray\nNumérico, Carácter, Complejo, Lógico\nDatos en varias dimensiones con elementos del mismo tipo (numérico, carácter, complejo, lógico).\nNo\nMulti-dimensional (2D, 3D, …)\n\n\nMatriz\nNumérico, Carácter, Complejo, Lógico\nColección bidimensional de elementos del mismo tipo (numérico, carácter, complejo, lógico).\nNo\n2D\n\n\nData Frame\nNumérico, Carácter, Complejo, Lógico\nSimilar a una matriz pero puede contener diferentes tipos de datos (numéricos, caracteres, etc.) en sus columnas.\nSí\n2D\n\n\nTS\nNumérico, Carácter, Complejo, Lógico\nSerie temporal (time series), un conjunto de datos ordenados por tiempo, del mismo tipo (numérico, carácter, complejo, lógico).\nNo\n1D (univariada) o 2D (multivariada)\n\n\nLista\nNumérico, Carácter, Complejo, Lógico, Función, Expresión, etc.\nContenedor flexible que puede almacenar elementos de diferentes tipos (numérico, carácter, complejo, lógico, función, expresión, etc.).\nSí\n1D (pero puede contener estructuras de cualquier dimensión)"
  },
  {
    "objectID": "Practicas_2024_25/Práctica_2/Práctica_2.1_pdf.html#operadores-básicos-en-r",
    "href": "Practicas_2024_25/Práctica_2/Práctica_2.1_pdf.html#operadores-básicos-en-r",
    "title": "3  Práctica 2. Introducción y manipulación de datos en R (1)",
    "section": "3.2 2. Operadores básicos en R",
    "text": "3.2 2. Operadores básicos en R\nVamos a hacer un resumen de los principales operadores y las funciones matemáticas más utilizadas en R\n\n\n\n\n\n\n\n\nOperador\nDescripción\nEjemplo\n\n\n\n\n==\nIgual a\nx == 5\n\n\n!=\nDistinto de\nx != 3\n\n\n>\nMayor que\nx > 3\n\n\n<\nMenor que\nx < 5\n\n\n>=\nMayor o igual que\nx >= 5\n\n\n<=\nMenor o igual que\nx <= 5\n\n\n&\nY lógico (AND)\nx>2 & x<3\n\n\n|\nO lógico (OR)\nx<2 | x>3\n\n\n!\nNegación lógica (NOT)\n!TRUE\n\n\nall()\nDevuelve TRUE si todos los elementos son TRUE\nall(c(TRUE, TRUE))\n\n\nany()\nDevuelve TRUE si al menos un elemento es TRUE\nany(c(FALSE, TRUE))\n\n\n\nAhora vamos a recordar las funciones matemáticas básicas más utilizadas\n\n\n\n\n\n\n\n\n\nFunción\nDescripción\nEjemplo\nResultado\n\n\n\n\n+\nSuma dos números\n5 + 3\n8\n\n\n-\nResta un número a otro\n5 - 3\n2\n\n\n*\nMultiplica dos números\n5 * 3\n15\n\n\n/\nDivide un número por otro\n6 / 3\n2\n\n\n^\nExponenciación\n2^3\n8\n\n\n%%\nResto de la división (módulo)\n5 %% 2\n1\n\n\n%/%\nDivisión entera\n5 %/% 2\n2\n\n\nround()\nRedondea a un número especificado de decimales\nround(3.14159, 2)\n3.14\n\n\nceiling()\nRedondea al entero superior más cercano\nceiling(2.3)\n3\n\n\nfloor()\nRedondea al entero inferior más cercano\nfloor(2.7)\n2\n\n\ntrunc()\nTrunca la parte decimal, dejando solo la parte entera\ntrunc(2.7)\n2\n\n\nsqrt()\nCalcula la raíz cuadrada\nsqrt(16)\n4\n\n\nexp()\nCalcula el exponencial de un número (e^x)\nexp(1)\n2.718.282\n\n\nlog()\nCalcula el logaritmo natural (base e)\nlog(10)\n2.302.585\n\n\nlog10()\nCalcula el logaritmo en base 10\nlog10(100)\n2\n\n\nlog2()\nCalcula el logaritmo en base 2\nlog2(8)\n3\n\n\nabs()\nCalcula el valor absoluto\nabs(-5)\n5\n\n\nsum()\nSuma todos los elementos de un vector\nsum(c(1, 2, 3))\n6\n\n\nprod()\nCalcula el producto de todos los elementos de un vector\nprod(c(1, 2, 3))\n6\n\n\nmean()\nCalcula el promedio de un conjunto de números\nmean(c(1, 2, 3))\n2\n\n\nmin()\nEncuentra el mínimo valor en un conjunto de números\nmin(c(1, 2, 3))\n1\n\n\nmax()\nEncuentra el máximo valor en un conjunto de números\nmax(c(1, 2, 3))\n3"
  },
  {
    "objectID": "Practicas_2024_25/Práctica_2/Práctica_2.1_pdf.html#vectores",
    "href": "Practicas_2024_25/Práctica_2/Práctica_2.1_pdf.html#vectores",
    "title": "3  Práctica 2. Introducción y manipulación de datos en R (1)",
    "section": "3.3 3. Vectores",
    "text": "3.3 3. Vectores\nUn vector es una secuencia ordenada de datos del mismo tipo (siendo éstos númericos, cadenas, fechas, etc). Es la estructura de datos más sencilla. Un simple valor (por ejemplo el número 5) constituye un vector numérico. Los escalares son vectores de longitud 1\n\nx<- 5\nx\n\n[1] 5\n\n\nPero un vector puede contener otro tipo de datos como cadenas de texto o datos lógicos\n\nx<- as.vector (TRUE)\nx\n\n[1] TRUE\n\ny<-as.vector(c(\"Andrés\", \"Luis\"))\ny\n\n[1] \"Andrés\" \"Luis\"  \n\n\n\n3.3.1 3.1 Creación de vectores\nEl vector es el elemento más básico en R, y contiene elementos de la misma clase.\nSe crea con la función c(), que significa ‘concatenar’ o ‘combinar’ y el paréntesis debe incluir r los datos que deseamos integrar en ese vector, separados por comas (y en caso de datos de tipo charater flanqueados por comillas).\n\n3.3.1.1 Vector formado por números enteros:\nCon la función concatenar\n\nx <- c(1,2,3,4,5,6,7,8,9,10)\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nHay otras formas de generar una secuencia de números\nCon expresiones específicas\n\nx <- 1:10\n# Crea un vector con elementos del 1 al 10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nEl operador : tiene prioridad\n\nx <- 1:10-2 #Primero se genera el vector 1:10 (de 1 a 10) y luego se resta -2 a cada elemento.\nx\n\n [1] -1  0  1  2  3  4  5  6  7  8\n\n\nSe pueden cambiar las prioridades usando paréntesis\n\nx <- 1:(10-2) # Genera una serie de 1 a 8\nx\n\n[1] 1 2 3 4 5 6 7 8\n\n\nSe puede crear secuencias de números enteros con sequence\n\nx<-sequence(4:5) \n#Genera una secuencia hasta 4 y otra hasta 5\nx\n\n[1] 1 2 3 4 1 2 3 4 5\n\n\nLa función seq es una función más general y flexible para generar secuencias numéricas. seq(from, to, by, length.out, along.with), Sus parámetros son from: El valor inicial de la secuencia. to: El valor final de la secuencia. by: El incremento (o decremento si es negativo) entre elementos de la secuencia. length.out: El número total de elementos en la secuencia. Si se especifica, el valor de by se ajusta automáticamente.\n\nx<- seq(1, 2, by= 0.1)\n#Genera una secuencia de números entre 1 y 2 con valores separados por 0,1 \nx \n\n [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0\n\nx<- seq(length=9, from=1, to=5)\n#La función seq crea una secuencia de 9 elementos, con valor inicial 1 y final 5. \nx\n\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n\n\nOtra forma de crear un vector con elementos repetidos es con rep\n\nx <-rep(1, 10) #Crea un vector en el que aparece 10 veces el numero 1 \nx\n\n [1] 1 1 1 1 1 1 1 1 1 1\n\n\nSe pueden generar secuencias con distribuciones fijas, por ejemplo la normal con la función rnorm\n\nx<-rnorm(10, 50, 5) # 10 valores de media 50 y desviación típica 5 \nx \n\n [1] 52.13386 44.80473 51.28910 58.58160 51.75478 47.47687 59.96166 57.74943\n [9] 44.36730 63.32676\n\n\nSe puede crear un vector con elementos repetidos en forma de series con la función gl (generate levels)\n\nx<-gl(3, 4) #gl (generate levels) genera un factor con 3 niveles (1, 2, 3),\\\n#repitiendo cada nivel 4 veces. \nx \n\n [1] 1 1 1 1 2 2 2 2 3 3 3 3\nLevels: 1 2 3\n\n\n\n\n3.3.1.2 Vector formado por caracteres:\nCada uno de los elementos de un vector de caracteres debe escribirse entre comillas. En caso contrario, la máquina devuelve un mensaje de error.\n\nciudades<- c(\"Jaen\", \"Córdoba\", \"Sevilla\")\nciudades\n\n[1] \"Jaen\"    \"Córdoba\" \"Sevilla\"\n\n\n\n\n3.3.1.3 Vector lógico:\nSolo requiere definir los valores verdaderos (TRUE) y falsos (FALSE):\n\nvector_logico <- c(TRUE, FALSE, TRUE, FALSE)\nprint(vector_logico)\n\n[1]  TRUE FALSE  TRUE FALSE\n\n\nLos vectores lógicos se pueden crear al poner una condición a otro vector:\n\n# Crear un vector numérico\nnumeros <- c(1, -5, 7, -2, 8, 9, 2)\n\n# Crear un vector lógico que indica si cada elemento es positivo o no\npositivo <- numeros>0\nprint(positivo)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE\n\n\n\n\n\n3.3.2 3.2 Operaciones con vectores\nLa primera operación que describiremos será comprobar si un objeto es un vector\n\nv0 <- 10\nv0\n\n[1] 10\n\nis.vector(v0) # Verificar si el objeto o variable 'v0' es un vector.\n\n[1] TRUE\n\n\nUna vez creados los vectores, pueden ser modificados posteriormente. Por ejemplo, si deseamos agregar un elemento a un vector ya existente, lo añadimos asignándolo a nuestro vector original.\nVamos a operar con el vector v1(2,5,10)\n\nv1<-c(2,5,10)\nv1\n\n[1]  2  5 10\n\n\nSe pueden añadir elementos a un vector\n\nv2<-c (v1,8)\nv2\n\n[1]  2  5 10  8\n\n\nAhora tenemos dos vectores v1(2,5,10) , v2(2,5,10,8)\nSe pueden realizar operaciones aritméticas con vectores. Se pueden sumar v1 y v2\n\nv1+v2\n\nWarning in v1 + v2: longitud de objeto mayor no es múltiplo de la longitud de\nuno menor\n\n\n[1]  4 10 20 10\n\n\nAviso en v1 + v2 : longitud de objeto mayor no es múltiplo de la longitud de uno menor. Al último valor de v2, le suma el primero de V1 (“reciclaje”)\nNo ocurriría si v1 y v2 tuviesen igual tamaño.\nTambién pueden multiplicarse v1 y v2\n\nv1*v2\n\nWarning in v1 * v2: longitud de objeto mayor no es múltiplo de la longitud de\nuno menor\n\n\n[1]   4  25 100  16\n\n\nAviso en v1*v2 : longitud de objeto mayor no es múltiplo de la longitud de uno menor. Multiplica último valor de v2, por el primero de V1 (“reciclaje”). #No ocurriría si v1 y v2 tuviesen igual tamaño.\nSe pueden elevar al cuadrado los términos de un vector\n\nv1^2 \n\n[1]   4  25 100\n\n\nLe podemos pedir a R que nos calcule la raiz cuadrada de los elementos de un vector con la función sqrt,\n\nsqrt (v2) #v2(2,5,10,8)\n\n[1] 1.414214 2.236068 3.162278 2.828427\n\n\nSe pueden sumar los términos de un vector, con la función ´sum´\n\nsum (v2) #v2(2,5,10,8) \n\n[1] 25\n\n\nSe puede calcular la media de los términos de un vector con la función ´mean´\n\nmean (v2) #v2(2,5,10,8)\n\n[1] 6.25\n\n\nAtención, si un vector tiene valores ausentes NA hay que hacérselo notar a la función. Imaginemos v3(0,10,8,NA,6)\n\nv3<-c(0,10,8,NA,6)\nmean (v3)\n\n[1] NA\n\n\nla forma correcta de calcular la media sería\n\nmean(v3, na.rm = TRUE)\n\n[1] 6\n\n\nExisten otras funciones que operan con los valores de un vector\n\nv3<-c(0,10,8,NA,6)\nlength(v3) #número de valores de v3\n\n[1] 5\n\nmax(v3,na.rm = TRUE) #Valor máximo de v3, sabiendo que hay valores NA\n\n[1] 10\n\nmin(v3, na.rm = TRUE) #Valor mínimo de v3, sabiendo que hay valores NA\n\n[1] 0\n\n\nSe puede operar con un solo vector\n\nv2*2+10\n\n[1] 14 20 30 26\n\n\nCuando le indicamos a R que calcule v2* 2 + 10, lo que realmente está calculando es:v2 * c(2, 2, 2, 2) + c(10, 10, 10, 10)\nAlgunas operaciones se pueden escribir de forma simplificada\n\nv2 + c (2, 10)\n\n[1]  4 15 12 18\n\n\nEsta operación suma 2 a los valores impares y 10 a los pares. Recuerde que v2(2,5,10,8)\n`\nLos elementos de un vector se pueden recuperar, por medio de corchetes. Siendo v1(2,5,10) v2(2,5,10,8)\n\nv1[2]\n\n[1] 5\n\nv2[3]\n\n[1] 10\n\n\nSe puede operar con valores de determinada posición de los vectores, vamos a sumar el valor de la segunda posición de v1 con el de la tercera posición de v2\n\nv1[2] +v2[3]\n\n[1] 15\n\n\nTambién se pueden añadir los corchetes para añadir un valor en una posición o para cambiarlo. Veamos v1(2,5,10)\n\nv1[4] <- 12\nv1\n\n[1]  2  5 10 12\n\nv1[2] <- 12\nv1\n\n[1]  2 12 10 12\n\n\nLos elementos de un vector se pueden recuperar en función de una orden lógica. Siendo v1(2,12,10,12)\n\nv1 > 7\n\n[1] FALSE  TRUE  TRUE  TRUE\n\nv1 < 7\n\n[1]  TRUE FALSE FALSE FALSE\n\nv1 == 12\n\n[1] FALSE  TRUE FALSE  TRUE\n\n\nTambién puede usarse la función which. Tenemos v3(0,10,8,NA,6)\n\nwhich(v3 > 2) # Posiciones de los elementos mayores que 2\n\n[1] 2 3 5\n\nwhich(v3 < 2 | v3 >= 8) # Posiciones de los elementos <2 o >= 8.  \n\n[1] 1 2 3\n\n\nAtención, hay un elemento NA, aunque R en esta versión lo identifica como tal, es más recomendable\n\nwhich(!is.na(v3) & v3 < 2 | v3 >= 8) \n\n[1] 1 2 3\n\n\nPosiciones de los elementos >2 y <= 8 sabiendo que existen valores ausentes."
  },
  {
    "objectID": "Practicas_2024_25/Práctica_2/Práctica_2.1_pdf.html#matrices",
    "href": "Practicas_2024_25/Práctica_2/Práctica_2.1_pdf.html#matrices",
    "title": "3  Práctica 2. Introducción y manipulación de datos en R (1)",
    "section": "3.4 4. Matrices",
    "text": "3.4 4. Matrices\nEn R, una matriz es una colección bidimensional de elementos que deben ser del mismo tipo (numérico, carácter, lógico, etc.).\n\n3.4.1 4.1 Creación de matrices\nLa función matrix() es la forma más común de crear matrices en R.\n\nmatrix(1:12, nrow = 4, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\n\nCuando no se especifica nada la matriz se cumplimenta por columnas.\nPero se puede pedir que se cumplimente por filas\n\nmatrix(1:12, nrow = 4, ncol = 3, byrow = TRUE)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n\n\nLa función matrix() se puede sustituir con la instrucción dim, que transforma un vector en una matriz\n\nx<-1:15\ndim(x) <- c(5, 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n\n\n\n\n3.4.2 4.2 Operaciones con matrices\nLas funciones básicas explicadas se pueden emplear en una matriz\n\nrange(x) #Rango de la matriz x\n\n[1]  1 15\n\nlength(x) #Número de elementos en la matriz x\n\n[1] 15\n\nmean(x) #Media de los valores de la matriz x\n\n[1] 8\n\nmedian(x) #Mediana de los valores de la matriz x\n\n[1] 8\n\nsum(x) #Suma de los valores de la matriz x\n\n[1] 120\n\nprod(x) #Producto de los valores de la matriz x\n\n[1] 1.307674e+12\n\nmax(x) #Valor máximo de la matriz x\n\n[1] 15\n\nmin(x) #Valor mínímo de la matriz x\n\n[1] 1\n\nwhich.max(x) # Devuelve el valor máximo de la matriz x\n\n[1] 15\n\nwhich.min(x) #Devuelve valor mínimo de la matriz x\n\n[1] 1\n\n\nLas matrices pueden unirse entre sí\n\nm1<-matrix(1:4, nrow=2, ncol=2)\nm2<-matrix(5:8, nrow=2, ncol=2)\nm1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nm2\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n\n\nSe pueden unir por filas con la orden rbind\n\nrbind (m1,m2)\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n[3,]    5    7\n[4,]    6    8\n\n\nY se puden unir por columnas con la orden cbind\n\ncbind (m1,m2)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n\n´Las matrices también se pueden sumar o multiplicar\n\nm1+m2\n\n     [,1] [,2]\n[1,]    6   10\n[2,]    8   12\n\nm1*m2\n\n     [,1] [,2]\n[1,]    5   21\n[2,]   12   32\n\n\nLas matrices se pueden transponer con la orden t\n\nt (m1)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\nt (m2)\n\n     [,1] [,2]\n[1,]    5    6\n[2,]    7    8\n\n\nLas filas y las columnas de las matrices pueden etiquetarse\n\ncolnames(m1) <- c(\"Columna 1\", \"Columna 2\")\nrownames (m1) <- c(\"Fila 1\", \"Fila 2\")\nm1\n\n       Columna 1 Columna 2\nFila 1         1         3\nFila 2         2         4\n\n\nLas posiciones de los valores de una matriz pueden recuperarse, supongamos una nueva matriz m3\n\nm3<- rbind(m1,m2)\nrownames (m3) <- c(\"Fila 1\", \"Fila 2\", \"Fila 3\", \"Fila 4\")\nm3\n\n       Columna 1 Columna 2\nFila 1         1         3\nFila 2         2         4\nFila 3         5         7\nFila 4         6         8\n\n\nVamos a intentar localizar algunas posiciones en la matriz\n\nm3[1,] # fila 1 todas las columnas.\n\nColumna 1 Columna 2 \n        1         3 \n\nm3[,2] # todas filas, columna 2\n\nFila 1 Fila 2 Fila 3 Fila 4 \n     3      4      7      8 \n\nm3[1:2,1] #filas 1 y 2,  columna 1 \n\nFila 1 Fila 2 \n     1      2 \n\nm3[-(1:2),2] #excluir filas 1 a 2, incluir columna 2.\n\nFila 3 Fila 4 \n     7      8 \n\nm3[,\"Columna 2\"] #La columna 2, usando el nombre de la columna\n\nFila 1 Fila 2 Fila 3 Fila 4 \n     3      4      7      8 \n\nm3[3,c(\"Columna 1\",\"Columna 2\")] # La fila 3 y todas las columnas, llamadas por su nombre\n\nColumna 1 Columna 2 \n        5         7"
  }
]