<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jesús Esteban Hernández, Jesús Martín Fernández">

<title>Práctica 4. Recodificación de variables</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Práctica 4_files/libs/clipboard/clipboard.min.js"></script>
<script src="Práctica 4_files/libs/quarto-html/quarto.js"></script>
<script src="Práctica 4_files/libs/quarto-html/popper.min.js"></script>
<script src="Práctica 4_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Práctica 4_files/libs/quarto-html/anchor.min.js"></script>
<link href="Práctica 4_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Práctica 4_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Práctica 4_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Práctica 4_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Práctica 4_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contenidos</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción">1. Introducción</a></li>
  <li><a href="#recodificación-basada-en-intervalos-de-la-distribución" id="toc-recodificación-basada-en-intervalos-de-la-distribución" class="nav-link" data-scroll-target="#recodificación-basada-en-intervalos-de-la-distribución">2. Recodificación basada en intervalos de la distribución</a></li>
  <li><a href="#recodificar-utilizando-información-de-otros-vectores" id="toc-recodificar-utilizando-información-de-otros-vectores" class="nav-link" data-scroll-target="#recodificar-utilizando-información-de-otros-vectores">3. Recodificar utilizando información de otros vectores</a></li>
  <li><a href="#recodificación-en-variables-tipo-factor" id="toc-recodificación-en-variables-tipo-factor" class="nav-link" data-scroll-target="#recodificación-en-variables-tipo-factor">4. Recodificación en variables tipo factor</a></li>
  <li><a href="#haciendo-factor-un-vector-character" id="toc-haciendo-factor-un-vector-character" class="nav-link" data-scroll-target="#haciendo-factor-un-vector-character">5. Haciendo factor un vector <code>character</code></a>
  <ul class="collapse">
  <li><a href="#controlar-el-orden-de-los-niveles" id="toc-controlar-el-orden-de-los-niveles" class="nav-link" data-scroll-target="#controlar-el-orden-de-los-niveles">4. <strong>Controlar el orden de los niveles:</strong></a></li>
  <li><a href="#recodificación-de-factores" id="toc-recodificación-de-factores" class="nav-link" data-scroll-target="#recodificación-de-factores">5. <strong>Recodificación de factores:</strong></a></li>
  <li><a href="#reordenar-niveles" id="toc-reordenar-niveles" class="nav-link" data-scroll-target="#reordenar-niveles">6. <strong>Reordenar niveles:</strong></a></li>
  <li><a href="#factores-ordenados" id="toc-factores-ordenados" class="nav-link" data-scroll-target="#factores-ordenados">7. <strong>Factores ordenados:</strong></a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span style="font-size:40px; font-weight:bold;">Práctica 4. Recodificación de variables</span></h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jesús Esteban Hernández, Jesús Martín Fernández </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introducción" class="level2">
<h2 class="anchored" data-anchor-id="introducción">1. Introducción</h2>
<p>El trabajo con datos en R es una parte esencial del análisis estadístico, y uno de los aspectos más importantes de este proceso es la recodificación de variables, especialmente en el caso de las variables de tipo factor. Los factores representan datos categóricos y, a menudo, contienen niveles que requieren ajustes para un análisis más preciso. Recodificar estos factores implica transformar sus niveles para que sean más representativos o relevantes para el estudio. Por ejemplo, puede ser necesario agrupar categorías, fusionar niveles o reordenar los factores de manera que reflejen un orden lógico. Además, los factores son esenciales para el correcto funcionamiento de muchos modelos estadísticos en R, ya que estos tratan las variables categóricas de manera diferente a las numéricas. No manejar adecuadamente los factores puede llevar a errores o interpretaciones incorrectas en los resultados. Por ello, es fundamental entender cómo trabajar con ellos y asegurarse de que las categorías reflejan de forma precisa la estructura de los datos.</p>
</section>
<section id="recodificación-basada-en-intervalos-de-la-distribución" class="level2">
<h2 class="anchored" data-anchor-id="recodificación-basada-en-intervalos-de-la-distribución">2. Recodificación basada en intervalos de la distribución</h2>
<p>Una de las formas más inmediatas de recodificar es recurrir a buscar puntos de corte en el rango de valores de un vector</p>
<p>Vamos a recuperar el dataframe df_prueba y a ver el recorrido de su variable (vector) edad</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>df_prueba <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"C:/Users/jesus.martin/OneDrive - Madrid Digital/Docente/Introducción a la AP/Curso 2024_25/Bioestadística 1/Prácticas/Práctica 3/df_prueba.csv"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span> (df_prueba<span class="sc">$</span>edad)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 42 83</code></pre>
</div>
</div>
<p>Vemos que la edad se distribuye entre los 42 y 83 años, así que vamos a categorizarla en intervalos de décadas con la función <code>cut</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>df_prueba<span class="sc">$</span>edad_r <span class="ot">&lt;-</span> <span class="fu">cut</span>(df_prueba<span class="sc">$</span>edad, <span class="at">breaks =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="cn">Inf</span>, <span class="dv">50</span>, <span class="dv">60</span>, <span class="dv">70</span>, <span class="dv">80</span>, <span class="cn">Inf</span>))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span> (df_prueba<span class="sc">$</span>edad_r)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
(-Inf,50]   (50,60]   (60,70]   (70,80] (80, Inf] 
       17        21        29        24         9 </code></pre>
</div>
</div>
<p>Recuerda que si hubiésemos querido que las categorías estuviesen abiertas por la derecha, el código sería:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>df_prueba<span class="sc">$</span>edad_r <span class="ot">&lt;-</span> <span class="fu">cut</span>(df_prueba<span class="sc">$</span>edad, <span class="at">breaks =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="cn">Inf</span>, <span class="dv">50</span>, <span class="dv">60</span>, <span class="dv">70</span>, <span class="dv">80</span>, <span class="cn">Inf</span>), <span class="at">right=</span><span class="cn">FALSE</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span> (df_prueba<span class="sc">$</span>edad_r)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
[-Inf,50)   [50,60)   [60,70)   [70,80) [80, Inf) 
       16        20        28        25        11 </code></pre>
</div>
</div>
</section>
<section id="recodificar-utilizando-información-de-otros-vectores" class="level2">
<h2 class="anchored" data-anchor-id="recodificar-utilizando-información-de-otros-vectores">3. Recodificar utilizando información de otros vectores</h2>
<p>La creación de nuevas variables a partir de dos o más vectores existentes es una práctica común en el análisis de datos. Esta técnica permite generar información adicional o más compleja que puede ser útil para interpretar, analizar o modelar mejor los datos. Como ya hemos hecho anteriormente vamos a crear el vector <code>imc</code> a partir de los vectores <code>peso</code> y <code>alt</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>df_prueba<span class="sc">$</span>imc <span class="ot">&lt;-</span> df_prueba<span class="sc">$</span>peso <span class="sc">/</span> (df_prueba<span class="sc">$</span>alt <span class="sc">/</span> <span class="dv">100</span>)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>df_prueba<span class="sc">$</span>imc <span class="ot">&lt;-</span> <span class="fu">round</span>(df_prueba<span class="sc">$</span>imc, <span class="dv">2</span>) <span class="co">#redondeamos a 2 decimales</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="recodificación-en-variables-tipo-factor" class="level2">
<h2 class="anchored" data-anchor-id="recodificación-en-variables-tipo-factor">4. Recodificación en variables tipo factor</h2>
<p>La recodificación de variables categóricas es una de las tareas más comunes en la manipulación de datos. En R, este proceso se realiza utilizando factores, una clase especial para manejar variables categóricas. Los factores asignan a cada valor único del vector (variable) original un nivel numérico subyacente (level), mientras que la etiqueta es el valor visible asociado (label). La confusión habitual entre niveles y etiquetas se resuelve al entender que los niveles son los valores internos que utiliza R para operar, mientras que las etiquetas son las representaciones visibles de esos niveles.</p>
<p>Vamos a recorrer ese camino con un ejemplo. Primero, generamos un vector numérico <code>x</code> que contiene los valores <code>0</code> y <code>1</code> repetidos varias veces. Luego, convertimos este vector en un factor utilizando la función <code>factor()</code>, lo que permite a R identificar los valores únicos y asignarles niveles numéricos subyacentes. Al no especificar etiquetas, R utiliza los valores originales como etiquetas y organiza los niveles en orden alfanumérico. Esto demuestra cómo R asigna niveles automáticamente a los valores de una variable categórica al convertirlos en factores.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>x<span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>,<span class="dv">25</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>sex<span class="ot">&lt;-</span> <span class="fu">factor</span> (x)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>sex</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
[39] 0 1 0 1 0 1 0 1 0 1 0 1
Levels: 0 1</code></pre>
</div>
</div>
<p>Si no asignas etiquetas explícitas al convertir un vector numérico en un factor en R, los valores visibles (las etiquetas) que asigna el factor serán los mismos que los valores originales del vector. Por ejemplo, si tienes un vector con valores <code>0</code> y <code>1</code> y lo conviertes en un factor sin especificar etiquetas, R usará esos mismos valores (<code>0</code> y <code>1</code>) como etiquetas visibles, pero internamente sigue asignando niveles numéricos (1 para “0” y 2 para “1”, según el orden alfanumérico). Así, aunque visualmente parezcan iguales, los números internos (niveles) son distintos de las etiquetas que ves. Puedes comprobarlo conviertiendo el vector en numérico.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>sex2<span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(sex)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>sex2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2
[39] 1 2 1 2 1 2 1 2 1 2 1 2</code></pre>
</div>
</div>
<p>Ahora vamos a asignar etiquetas al factor. Vamos a pedirle que asigne la etiqueta “Mujer” al nivel <code>1</code> (que se corresponde con el valor “0”) y “Hombre” al nivel <code>2</code> (que corresponde al valor “1”).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>sex2 <span class="ot">&lt;-</span> <span class="fu">factor</span>(x, <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"Mujer"</span>, <span class="st">"Hombre"</span>))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>sex2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre
[11] Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre
[21] Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre
[31] Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre
[41] Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre
Levels: Mujer Hombre</code></pre>
</div>
</div>
<p>Pero los niveles subyacentes seguirán siendo <code>1</code> y <code>2</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>sex2<span class="ot">&lt;-</span> <span class="fu">as.numeric</span> (sex2)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>sex2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2
[39] 1 2 1 2 1 2 1 2 1 2 1 2</code></pre>
</div>
</div>
<p>Si queremos saber los niveles de un vector factor, simplemente hay que usar la función <code>levels</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>sex2 <span class="ot">&lt;-</span> <span class="fu">factor</span>(x, <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"Mujer"</span>, <span class="st">"Hombre"</span>))</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">levels</span> (sex2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Mujer"  "Hombre"</code></pre>
</div>
</div>
<p>Finalmente, señalamos que se pueden cambiar de orden los niveles a criterio del investigador , utilizando también la función <code>level</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>sex3 <span class="ot">&lt;-</span> <span class="fu">factor</span>(x, <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"1"</span>, <span class="st">"0"</span>))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>sex3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
[39] 0 1 0 1 0 1 0 1 0 1 0 1
Levels: 1 0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>sex3 <span class="ot">&lt;-</span> <span class="fu">factor</span>(sex3, <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"Mujer"</span>, <span class="st">"Hombre"</span>))</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>sex3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer 
[11] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer 
[21] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer 
[31] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer 
[41] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer 
Levels: Mujer Hombre</code></pre>
</div>
</div>
<p>La importancia del orden en los niveles de un factor en R radica en cómo R trata esas categorías en modelos estadísticos, especialmente en modelos lineales o regresiones. En estos modelos, uno de los niveles de la variable categórica se utiliza como nivel de referencia, es decir, como punto base para comparar las otras categorías.</p>
<p>Por defecto, R usa el nivel más bajo (en orden alfanumérico) como referencia. Por ejemplo, si tienes un factor con los niveles “Mujer” (1) y “Hombre” (2) (como ocurría con <code>sex</code> y <code>sex2</code>, el modelo tomará “Mujer” como referencia y calculará los efectos de “Hombre” en relación a “Mujer”. Esto influye en cómo se interpretan los coeficientes del modelo: los valores obtenidos para “Hombre” serán comparaciones con respecto a “Mujer”. Cambiar el orden de los niveles altera qué categoría se usa como referencia, lo que puede ser crucial para una correcta interpretación de los resultados.</p>
<p>Si prefieres que “Hombre” sea la referencia en lugar de “Mujer”, debes ajustar los niveles del factor para que “Hombre” sea el primer nivel (como ocurría con la variable <code>sex3</code>).</p>
</section>
<section id="haciendo-factor-un-vector-character" class="level2">
<h2 class="anchored" data-anchor-id="haciendo-factor-un-vector-character">5. Haciendo factor un vector <code>character</code></h2>
<p>Es común convertir un vector de texto en un factor. Supongamos que tenemos un vector con categorías socioeconómicas (NSE) como cadenas de texto:</p>
<pre><code>r</code></pre>
<p>Copiar código</p>
<p><code>nse &lt;- c(rep('NSE1', 10), rep('NSE2', 4), rep('NSE3', 12), rep('NSE4', 5))</code></p>
<p>Este vector tiene valores repetidos de “NSE1”, “NSE2”, etc. Al convertirlo en un factor, R asignará niveles según el orden alfanumérico de las etiquetas:</p>
<pre><code>r</code></pre>
<p>Copiar código</p>
<p><code>nse_f &lt;- factor(nse) nse_f # [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2 NSE2 NSE2 NSE2 NSE3 ... # Levels: NSE1 NSE2 NSE3 NSE4</code></p>
<p>R ordena automáticamente los niveles en orden alfabético: “NSE1”, “NSE2”, “NSE3”, “NSE4”.</p>
<section id="controlar-el-orden-de-los-niveles" class="level3">
<h3 class="anchored" data-anchor-id="controlar-el-orden-de-los-niveles">4. <strong>Controlar el orden de los niveles:</strong></h3>
<p>Si tenemos un vector con nombres que no siguen un patrón alfabético, como “SNE2” en lugar de “NSE2”, R ajustará el orden de los niveles según el nuevo orden alfabético:</p>
<pre><code>r</code></pre>
<p>Copiar código</p>
<p><code>nse2 &lt;- c(rep('NSE1', 10), rep('SNE2', 4), rep('NSE3', 12), rep('NSE4', 5)) nse2_f &lt;- factor(nse2) nse2_f # [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 SNE2 SNE2 SNE2 SNE2 NSE3 ... # Levels: NSE1 NSE3 NSE4 SNE2</code></p>
<p>Aquí vemos que “SNE2” se coloca después de “NSE4” debido al orden alfabético. Si queremos forzar un orden específico para los niveles, lo podemos hacer al crear el factor:</p>
<pre><code>r</code></pre>
<p>Copiar código</p>
<p><code>nse2_f2 &lt;- factor(nse2, levels = c('NSE1', 'SNE2', 'NSE3', 'NSE4')) nse2_f2 # [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 SNE2 SNE2 SNE2 SNE2 NSE3 ... # Levels: NSE1 SNE2 NSE3 NSE4</code></p>
</section>
<section id="recodificación-de-factores" class="level3">
<h3 class="anchored" data-anchor-id="recodificación-de-factores">5. <strong>Recodificación de factores:</strong></h3>
<p>La recodificación es útil cuando queremos agrupar niveles. Por ejemplo, si queremos agrupar “NSE2” y “NSE3” en una sola categoría:</p>
<pre><code>r</code></pre>
<p>Copiar código</p>
<p><code>nse_f_rec &lt;- nse_f levels(nse_f_rec) &lt;- c('NSE1', 'NSE2_3', 'NSE2_3', 'NSE4') nse_f_rec # [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2_3 NSE2_3 NSE2_3 ... # Levels: NSE1 NSE2_3 NSE4</code></p>
<p>Aquí hemos recodificado los niveles “NSE2” y “NSE3” como una nueva categoría llamada “NSE2_3”, reduciendo los niveles a tres: “NSE1”, “NSE2_3”, y “NSE4”.</p>
</section>
<section id="reordenar-niveles" class="level3">
<h3 class="anchored" data-anchor-id="reordenar-niveles">6. <strong>Reordenar niveles:</strong></h3>
<p>También podemos reordenar los niveles para cambiar cuál se usa como referencia en los modelos estadísticos. Por ejemplo, para hacer que “NSE4” sea el nivel de referencia:</p>
<pre><code>r</code></pre>
<p>Copiar código</p>
<p><code>nse_f_rec &lt;- relevel(nse_f_rec, ref = 'NSE4') nse_f_rec # [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2_3 NSE2_3 ... # Levels: NSE4 NSE1 NSE2_3</code></p>
<p>Ahora, “NSE4” es el primer nivel y se usará como referencia en análisis estadísticos.</p>
</section>
<section id="factores-ordenados" class="level3">
<h3 class="anchored" data-anchor-id="factores-ordenados">7. <strong>Factores ordenados:</strong></h3>
<p>Finalmente, si los niveles tienen un orden lógico (como NSE1 &lt; NSE2 &lt; NSE3 &lt; NSE4), podemos crear un <strong>factor ordenado</strong>:</p>
<pre><code>r</code></pre>
<p>Copiar código</p>
<p><code>nse_of &lt;- factor(nse, ordered = TRUE) nse_of # [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2 NSE2 NSE2 ... # Levels: NSE1 &lt; NSE2 &lt; NSE3 &lt; NSE4</code></p>
<p>Esto indica que R entiende que hay una relación de orden entre los niveles, útil en modelos donde el orden importa, como análisis de tendencias o jerarquías.</p>
<p>Estas herramientas permiten flexibilidad para manejar factores en R, asegurando que las etiquetas y los niveles sean interpretados correctamente en tus análisis</p>
<p>Todo esto está realizado con funciones básicas de R, lo que llamamos base R. En la realidad, se utiliza lo que se ha dado en llamar modern R, que automatiza y amplía las posibilidades de estas operaciones de gestión de datos. Sin embargo, en mi experiencia, no entender cómo piensa R (indexación de vectores, matrices y dataframes, utilización de factores, tipos de vector…), hace más difícil resolver los problemas que surjan al utilizar enfoques más eficientes (modern R), pero más complejos. Algo semejante pasará con los gráficos. R base construye buenos gráficos, y aunque permiten mucha personalización, hacerlo conlleva mucho código. El paquete ggplot2 facilita mucho la tarea de construcción de gráficos una vez se entiende ‘the Grammar of Graphics’ pero, para aprovechar su potencial al máximo, es útil entender como crear gráficos sencillos en R base, aunque debo reconocer que no todos los que nos dedicamos a la enseñanza estamos de acuerdo en esta cuestión. Guardar los datos para la siguiente sesión. Una vez hemos trabajado los datos en R, no tendría mucho sentido volver a exportarlos con las nuevas variables creadas, salvo que deseemos enviárselo a alguien que no utilice R o no pueda importar su formato de datos. Podríamos guardar toda la imagen del espacio de trabajo (Workspace) y cargarla antes de trabajar con el nuevo dataframe en la siguiente sesión. Sin embargo, y aunque cueste entenderlo al principio, es preferible guadar la menor cantida de objetos posibles y tratar de que sea el código el que lo construya cada vez. Si el objeto es muy grande o lleva mucho tiempo volver a generarlo con código, puede estar justificado guardar el o los objetos concretos. En el caso del dataframe tenemos una estructura de datos que le sirve a R para gestionar esta parte. Son los archivos .RDS. En este vínculo explican las dos opciones, pero de momento prefiero utilizar un archivo .RDS. Solo necesita un par de argumentos, el nombre del objeto dataframe que queremos guardar y el nombre del archivo en el que queremos guardarlo. El dataframe que nos interesa es iam, porque contiene las nuevas variables y las transformaciones que hemos realizado. Incluyo los nombres de los argumentos, pero dado que son los dos primeros en realidad no haría falta1. saveRDS(object=iam,file=‘iam.RDS’) Es importante que lo salvéis, porque lo cargaremos en la siguiente sesión. Así no tendremos que volver a generar todas las funciones de nuevo.</p>
<section id="section" class="level6">
<h6 class="anchored" data-anchor-id="section"></h6>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>